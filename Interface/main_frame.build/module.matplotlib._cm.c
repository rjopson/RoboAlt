/* Generated code for Python module 'matplotlib._cm'
 * created by Nuitka version 0.6.4
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_matplotlib$_cm" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_matplotlib$_cm;
PyDictObject *moduledict_matplotlib$_cm;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_RdPu;
static PyObject *const_dict_3adc72b697f1d7d162e0d950131b4b5a;
extern PyObject *const_str_plain___spec__;
static PyObject *const_str_plain__g33;
static PyObject *const_str_plain__YlGnBu_data;
static PyObject *const_float_1_78277;
static PyObject *const_str_plain__PiYG_data;
extern PyObject *const_str_plain_gamma;
extern PyObject *const_str_plain_i;
static PyObject *const_dict_d6323100fc0b68b2862861068aa9dfb4;
static PyObject *const_str_plain__wistia_data;
static PyObject *const_str_plain_BuGn;
static PyObject *const_str_plain__gist_yarg_data;
extern PyObject *const_float_minus_1_5;
static PyObject *const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple;
static PyObject *const_str_plain__jet_data;
static PyObject *const_str_plain__flag_data;
static PyObject *const_tuple_db9a981db24a26ea90b278665de2841d_tuple;
static PyObject *const_str_plain__g5;
extern PyObject *const_str_plain_m;
static PyObject *const_str_plain_ocean;
static PyObject *const_dict_ac09b61043b30f22f2e956405ad79658;
extern PyObject *const_int_pos_5;
static PyObject *const_str_plain__RdGy_data;
extern PyObject *const_str_plain_cool;
extern PyObject *const_int_pos_32;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_plain__g6;
static PyObject *const_str_plain_YlOrBr;
static PyObject *const_dict_8f097861f42f3010bd8f6de6022ffc3c;
static PyObject *const_str_plain__brg_data;
static PyObject *const_str_plain__g12;
static PyObject *const_str_plain__g26;
static PyObject *const_str_plain__gist_gray_data;
extern PyObject *const_str_plain_numpy;
extern PyObject *const_str_plain_red;
static PyObject *const_str_plain_OrRd;
extern PyObject *const_str_plain_listed;
static PyObject *const_str_plain_tab10;
extern PyObject *const_int_neg_2;
extern PyObject *const_float_1_0;
static PyObject *const_str_digest_0870d49f1cf88348cb56a7f4adc73408;
static PyObject *const_str_plain_gist_stern;
static PyObject *const_str_plain__g22;
static PyObject *const_str_plain__gist_heat_green;
extern PyObject *const_float_0_67;
static PyObject *const_str_plain__Pastel1_data;
static PyObject *const_tuple_ac83b7f87b65db8bc61c88a0c684aae6_tuple;
static PyObject *const_str_plain__flag_red;
static PyObject *const_str_plain__BuPu_data;
static PyObject *const_str_plain_PuBu;
static PyObject *const_str_plain__g23;
static PyObject *const_tuple_a1c2e0d0fdb72592d26c53db2b423104_tuple;
static PyObject *const_str_plain__autumn_data;
extern PyObject *const_str_plain_False;
static PyObject *const_str_plain__g16;
static PyObject *const_str_plain__BuGn_data;
extern PyObject *const_str_plain_green;
static PyObject *const_str_plain__g9;
static PyObject *const_str_plain__bwr_data;
static PyObject *const_str_plain__CMRmap_data;
static PyObject *const_dict_13dcc09e8b14458a914dc22a80eeee13;
extern PyObject *const_int_0;
static PyObject *const_str_plain__g4;
extern PyObject *const_str_plain_p1;
static PyObject *const_dict_1b20bf7e6394a197db2b925f2ae9f1f2;
static PyObject *const_str_plain_gist_heat;
static PyObject *const_str_digest_1ef270d0d79fb0bf55f236f47bc46446;
static PyObject *const_tuple_dbd02ca2a43f79960ecaa20263657c10_tuple;
static PyObject *const_str_plain__gist_earth_data;
static PyObject *const_str_plain__tab20_data;
static PyObject *const_str_plain_terrain;
static PyObject *const_str_plain__Oranges_data;
extern PyObject *const_int_pos_36;
extern PyObject *const_int_pos_4;
extern PyObject *const_str_plain___cached__;
extern PyObject *const_str_plain_functools;
static PyObject *const_float_minus_1_1;
static PyObject *const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple;
extern PyObject *const_str_plain_partial;
extern PyObject *const_int_pos_1;
static PyObject *const_dict_7ba6c40e971dab085fcf28da729f7167;
static PyObject *const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple;
static PyObject *const_str_plain__ch_helper;
extern PyObject *const_float_0_33;
static PyObject *const_tuple_9e6a97cefbfc93e4dbd6fe4790754edf_tuple;
static PyObject *const_str_plain__afmhot_data;
static PyObject *const_float_20_9;
extern PyObject *const_str_plain_hsv;
extern PyObject *const_str_plain_flag;
extern PyObject *const_str_plain_format;
static PyObject *const_str_plain_gnuplot;
static PyObject *const_str_plain__YlOrBr_data;
static PyObject *const_str_plain__tab20c_data;
extern PyObject *const_str_plain_blue;
static PyObject *const_str_plain_tab20;
static PyObject *const_str_plain_Pastel1;
static PyObject *const_str_plain_coolwarm;
static PyObject *const_str_plain_Set3;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_h;
static PyObject *const_str_plain__cool_data;
static PyObject *const_str_plain__prism_green;
extern PyObject *const_str_digest_70f25990f64eb086931fae485976330d;
static PyObject *const_str_plain__prism_red;
extern PyObject *const_float_1_84;
static PyObject *const_tuple_9b04358fc83d8c29f6d13e55a485e086_tuple;
static PyObject *const_tuple_e22ad1a6fd2b90375e84cff21f64303a_tuple;
static PyObject *const_str_plain__g19;
static PyObject *const_tuple_ef7272d3c529510edf3b0815822dbaa3_tuple;
static PyObject *const_dict_46fdda9c2313b830d68498039918be48;
static PyObject *const_tuple_122f654ebd563953484696204c943f8b_tuple;
static PyObject *const_str_plain_gist_yarg;
static PyObject *const_str_plain__gnuplot2_data;
extern PyObject *const_float_0_25;
static PyObject *const_dict_26510cda7d1dc75818c57eac9563d1d1;
extern PyObject *const_str_plain_Accent;
extern PyObject *const_float_0_5;
static PyObject *const_str_plain__g13;
static PyObject *const_tuple_6eb90b29c730cddab6ab1d936156a49c_tuple;
static PyObject *const_str_plain__g31;
static PyObject *const_tuple_de81471e775d0db13ccc93277369c0bb_tuple;
static PyObject *const_str_plain__flag_green;
static PyObject *const_tuple_2a4c4f5b12a7944706ab0b855d978f15_tuple;
static PyObject *const_tuple_4d8a3db908fea5ac787eae57a231d107_tuple;
static PyObject *const_int_pos_33;
static PyObject *const_tuple_fb0dd03a0e957d10a507ea76b9c3ad27_tuple;
static PyObject *const_str_plain__g30;
static PyObject *const_str_plain_gist_gray;
extern PyObject *const_str_plain_bone;
static PyObject *const_tuple_1cf08670e58213d33381f121283ddef7_tuple;
static PyObject *const_str_plain__seismic_data;
static PyObject *const_str_plain__gist_yarg;
static PyObject *const_str_plain__PRGn_data;
static PyObject *const_str_plain_RdGy;
static PyObject *const_str_plain__bone_data;
static PyObject *const_str_plain_Paired;
static PyObject *const_str_plain__g0;
extern PyObject *const_tuple_float_1_0_float_1_0_float_1_0_tuple;
static PyObject *const_str_plain__g15;
static PyObject *const_str_plain__winter_data;
static PyObject *const_str_plain_bwr;
extern PyObject *const_int_pos_34;
static PyObject *const_str_plain__Set1_data;
static PyObject *const_float_minus_0_29227;
static PyObject *const_str_plain__g2;
static PyObject *const_dict_61e4a4a8cd2b4181694d4cfb1751640d;
static PyObject *const_str_plain_Set1;
static PyObject *const_str_plain__gist_heat_data;
extern PyObject *const_str_plain_abs;
static PyObject *const_str_plain_YlGn;
static PyObject *const_str_plain__BrBG_data;
static PyObject *const_str_plain_gfunc;
static PyObject *const_tuple_13493111d1a4f8c8a058ebd7f95c09b1_tuple;
static PyObject *const_tuple_9fa91c64747bb6ff4492053856cc06e7_tuple;
static PyObject *const_str_plain__Set3_data;
static PyObject *const_str_plain__terrain_data;
extern PyObject *const_int_pos_15;
static PyObject *const_dict_a6becc14d04a47becd62ae70b4c4482c;
static PyObject *const_str_plain__Purples_data;
extern PyObject *const_str_plain_origin;
extern PyObject *const_str_plain_prism;
static PyObject *const_dict_79ecbf763b054a3ad895cae3fb89c58e;
static PyObject *const_tuple_d6bde7eec8df9cf0ee10c9abbaa88fc9_tuple;
static PyObject *const_str_plain_PRGn;
extern PyObject *const_str_plain_gray;
extern PyObject *const_str_plain_autumn;
extern PyObject *const_str_plain_copper;
static PyObject *const_tuple_float_0_5_float_0_0_float_0_0_tuple;
static PyObject *const_str_plain__gist_rainbow_data;
static PyObject *const_dict_cc81f270cbb7633b5af45d15d4c591ec;
static PyObject *const_str_plain_RdYlGn;
static PyObject *const_float_1_97294;
static PyObject *const_str_digest_36fea1563816aa379d3cd2c1ac36c445;
static PyObject *const_str_plain_gnuplot2;
extern PyObject *const_str_plain_zeros;
static PyObject *const_tuple_float_0_0_float_0_0_float_0_3_tuple;
static PyObject *const_str_digest_0ec62d994d1e365c7efad4dabaaba134;
extern PyObject *const_str_plain_xg;
static PyObject *const_str_plain_Oranges;
static PyObject *const_float_0_78125;
static PyObject *const_str_plain__prism_data;
static PyObject *const_dict_e5f8cd4b8b884f01b9dbdb6c0cf95972;
static PyObject *const_str_plain__Spectral_data;
extern PyObject *const_str_plain_hot;
static PyObject *const_str_plain__g36;
static PyObject *const_xrange_0_37;
extern PyObject *const_str_plain_has_location;
static PyObject *const_tuple_b84fc382b1c73eb24052e00184983189_tuple;
extern PyObject *const_float_0_0;
static PyObject *const_str_plain__YlGn_data;
static PyObject *const_str_plain__g21;
static PyObject *const_str_plain__copper_data;
static PyObject *const_tuple_4f66db73ea9fdbfdceb9e620df1e4919_tuple;
static PyObject *const_str_plain_Purples;
extern PyObject *const_tuple_str_plain_i_tuple;
static PyObject *const_tuple_20bd1f5c0a0f9a93d11e666cd7289af4_tuple;
extern PyObject *const_float_1_5;
extern PyObject *const_str_plain_phi;
extern PyObject *const_str_plain_winter;
static PyObject *const_str_plain__summer_data;
static PyObject *const_str_plain__RdYlGn_data;
static PyObject *const_tuple_8a21be97bcec74887e2b70da615f70d9_tuple;
static PyObject *const_tuple_440d7807917857d4ae4d4cd0c76093e7_tuple;
static PyObject *const_str_plain_Greys;
extern PyObject *const_int_pos_31;
extern PyObject *const_int_pos_23;
static PyObject *const_tuple_194951aabc8c4d0f914fa1c18e921dac_tuple;
static PyObject *const_str_plain__g28;
static PyObject *const_str_plain_YlGnBu;
static PyObject *const_tuple_58dec871a15dc46004a9c29f566fd8e9_tuple;
static PyObject *const_str_plain_PiYG;
static PyObject *const_str_plain_seismic;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain__Greens_data;
static PyObject *const_dict_e67366b36b736b2b1824e4124103e620;
extern PyObject *const_float_0_08;
extern PyObject *const_str_plain_s;
static PyObject *const_str_plain_gist_earth;
static PyObject *const_str_plain__Reds_data;
extern PyObject *const_str_plain_pi;
static PyObject *const_str_plain__gist_stern_data;
static PyObject *const_str_plain__nipy_spectral_data;
static PyObject *const_str_plain__tab20b_data;
static PyObject *const_str_plain_CMRmap;
static PyObject *const_str_plain_PuBuGn;
static PyObject *const_str_plain__PuOr_data;
extern PyObject *const_tuple_empty;
extern PyObject *const_int_pos_10;
static PyObject *const_tuple_7eb55817b097308a4aa82a88a7a374a0_tuple;
static PyObject *const_dict_139fa967a21793ecdbc3e590120916a2;
static PyObject *const_float_0_92;
static PyObject *const_str_plain__g25;
static PyObject *const_tuple_d09dc699a96e56cc6c61b2a9d13ae443_tuple;
static PyObject *const_str_plain__rainbow_data;
static PyObject *const_str_plain__g27;
static PyObject *const_str_plain__gist_heat_blue;
static PyObject *const_str_plain__g24;
static PyObject *const_float_11_5;
static PyObject *const_tuple_6430e1188db9556163de382028b9d704_tuple;
static PyObject *const_tuple_float_0_0_float_0_0_float_1_0_tuple;
extern PyObject *const_int_pos_37;
static PyObject *const_str_plain_PuRd;
static PyObject *const_str_plain_RdBu;
static PyObject *const_str_plain__spring_data;
static PyObject *const_dict_a065b631920800bd13e7ea9419838858;
extern PyObject *const_str_plain_x;
static PyObject *const_str_plain__g17;
static PyObject *const_str_digest_f73618ed65447e45c026300593ea43e2;
static PyObject *const_str_plain_PuOr;
static PyObject *const_str_plain__Paired_data;
extern PyObject *const_int_pos_13;
static PyObject *const_str_plain__hsv_data;
static PyObject *const_str_plain__RdBu_data;
static PyObject *const_tuple_d0062c44ff73c1c48f3f7d27f6672421_tuple;
extern PyObject *const_str_plain_p0;
static PyObject *const_float_31_5;
static PyObject *const_tuple_259735cef93a8d5cd32533f90f8ce8d3_tuple;
extern PyObject *const_str_plain_Spectral;
static PyObject *const_str_plain_Wistia;
static PyObject *const_float_minus_0_14861;
static PyObject *const_str_plain__binary_data;
static PyObject *const_dict_fd4a49377d1d658f7d30b821b6352628;
static PyObject *const_tuple_float_0_0_float_1_0_float_0_0_tuple;
static PyObject *const_tuple_391173ce944bd5a033152d725addac81_tuple;
extern PyObject *const_str_plain_sqrt;
static PyObject *const_str_plain__g10;
static PyObject *const_tuple_dd7b62811603d0af86732a1f25835a50_tuple;
extern PyObject *const_str_plain_binary;
static PyObject *const_str_plain_Greens;
static PyObject *const_str_plain__ocean_data;
extern PyObject *const_str_plain_np;
static PyObject *const_str_plain__prism_blue;
extern PyObject *const_int_pos_35;
static PyObject *const_str_plain__g20;
static PyObject *const_str_plain__RdPu_data;
static PyObject *const_str_plain__g14;
extern PyObject *const_str_plain_summer;
static PyObject *const_str_plain__tab10_data;
extern PyObject *const_str_angle_dictcontraction;
static PyObject *const_tuple_cc9102d236a92569966c4ebd4c8fbcf5_tuple;
extern PyObject *const_float_0_75;
static PyObject *const_tuple_b19a69e04a28b726d8b7d59807ef8eef_tuple;
static PyObject *const_str_plain__g8;
static PyObject *const_str_plain__PuBu_data;
static PyObject *const_tuple_2fe5f075a061fd18cc310f1b06eb16ae_tuple;
extern PyObject *const_str_plain_ret;
static PyObject *const_str_plain_Reds;
static PyObject *const_str_plain__g11;
extern PyObject *const_str_plain_a;
extern PyObject *const_str_plain_sin;
static PyObject *const_tuple_16581877f4601a2ddb7154cb6281285a_tuple;
extern PyObject *const_str_plain_spring;
extern PyObject *const_tuple_str_plain_partial_tuple;
static PyObject *const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple;
static PyObject *const_tuple_eb5d9c64a7345357330502cba765a133_tuple;
extern PyObject *const_str_plain_cos;
static PyObject *const_tuple_float_1_0_float_0_0_float_0_0_tuple;
static PyObject *const_float_0_32;
static PyObject *const_tuple_db58afb74f702702860a0cdf1356a649_tuple;
static PyObject *const_str_plain__g35;
static PyObject *const_str_plain_brg;
extern PyObject *const_int_pos_30;
static PyObject *const_str_plain__flag_blue;
static PyObject *const_tuple_3f501f1fed43a18bc40d5702c0cd69db_tuple;
static PyObject *const_str_plain__Blues_data;
static PyObject *const_str_plain_afmhot;
static PyObject *const_str_plain__PuRd_data;
static PyObject *const_str_plain_BuPu;
static PyObject *const_str_plain__g34;
static PyObject *const_str_plain__Set2_data;
static PyObject *const_str_plain_Pastel2;
extern PyObject *const_str_plain_jet;
static PyObject *const_str_plain_GnBu;
static PyObject *const_str_plain__PuBuGn_data;
extern PyObject *const_str_plain_nipy_spectral;
static PyObject *const_str_plain__YlOrRd_data;
static PyObject *const_str_plain__Greys_data;
static PyObject *const_str_plain_gist_rainbow;
static PyObject *const_tuple_str_plain_x_str_plain_ret_str_plain_m_tuple;
static PyObject *const_str_plain_gist_ncar;
static PyObject *const_str_plain__g29;
static PyObject *const_str_plain__gray_data;
static PyObject *const_str_plain__gnuplot_data;
static PyObject *const_str_plain_tab20c;
extern PyObject *const_str_plain_r;
static PyObject *const_str_digest_68bcfeed91a2fbe6bb71f773db17210e;
extern PyObject *const_tuple_str_plain_x_tuple;
extern PyObject *const_float_0_3;
static PyObject *const_str_plain__g3;
static PyObject *const_str_plain__pink_data;
static PyObject *const_dict_61b96e51e18659e8ba92a9cb886c68eb;
static PyObject *const_str_plain_Blues;
static PyObject *const_str_plain_rainbow;
static PyObject *const_str_plain_cubehelix;
static PyObject *const_tuple_2bea485d544db289d067c788ebf78b62_tuple;
extern PyObject *const_str_plain_pink;
static PyObject *const_dict_d876a613e78a88b4cea47cbcba7077b2;
static PyObject *const_str_plain__hot_data;
static PyObject *const_str_plain__g7;
static PyObject *const_tuple_6e6f4e9a37231f81f1e456047fd8c742_tuple;
static PyObject *const_str_plain_YlOrRd;
static PyObject *const_float_0_84;
static PyObject *const_str_plain__RdYlBu_data;
static PyObject *const_str_plain__cubehelix_data;
static PyObject *const_str_plain__Pastel2_data;
static PyObject *const_str_plain__gist_ncar_data;
extern PyObject *const_str_plain_datad;
static PyObject *const_str_plain_tab20b;
static PyObject *const_str_plain__OrRd_data;
static PyObject *const_str_plain__gist_heat_red;
static PyObject *const_str_plain__g18;
static PyObject *const_tuple_53dc862f8960bed320d0251ce04aeaf0_tuple;
static PyObject *const_str_plain__Accent_data;
static PyObject *const_tuple_a22c772c730dca9240495aa06353c5e0_tuple;
static PyObject *const_str_plain__coolwarm_data;
static PyObject *const_str_plain_Set2;
extern PyObject *const_int_pos_3;
static PyObject *const_float_minus_0_90649;
extern PyObject *const_int_pos_7;
extern PyObject *const_int_pos_28;
static PyObject *const_str_plain_RdYlBu;
static PyObject *const_str_plain__GnBu_data;
extern PyObject *const_int_pos_2;
static PyObject *const_str_plain__Dark2_data;
static PyObject *const_str_plain_BrBG;
static PyObject *const_str_plain_Dark2;
static PyObject *const_str_plain__g1;
static PyObject *const_str_plain__g32;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants( void )
{
    const_str_plain_RdPu = UNSTREAM_STRING_ASCII( &constant_bin[ 755771 ], 4, 1 );
    const_dict_3adc72b697f1d7d162e0d950131b4b5a = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 755775 ], 200 );
    const_str_plain__g33 = UNSTREAM_STRING_ASCII( &constant_bin[ 755975 ], 4, 1 );
    const_str_plain__YlGnBu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 755979 ], 12, 1 );
    const_float_1_78277 = UNSTREAM_FLOAT( &constant_bin[ 755991 ] );
    const_str_plain__PiYG_data = UNSTREAM_STRING_ASCII( &constant_bin[ 755999 ], 10, 1 );
    const_dict_d6323100fc0b68b2862861068aa9dfb4 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 756009 ], 200 );
    const_str_plain__wistia_data = UNSTREAM_STRING_ASCII( &constant_bin[ 756209 ], 12, 1 );
    const_str_plain_BuGn = UNSTREAM_STRING_ASCII( &constant_bin[ 756221 ], 4, 1 );
    const_str_plain__gist_yarg_data = UNSTREAM_STRING_ASCII( &constant_bin[ 756225 ], 15, 1 );
    const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple, 0, const_str_plain_gamma ); Py_INCREF( const_str_plain_gamma );
    PyTuple_SET_ITEM( const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple, 1, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple, 2, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    PyTuple_SET_ITEM( const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple, 3, const_str_plain_h ); Py_INCREF( const_str_plain_h );
    const_str_plain__jet_data = UNSTREAM_STRING_ASCII( &constant_bin[ 756240 ], 9, 1 );
    const_str_plain__flag_data = UNSTREAM_STRING_ASCII( &constant_bin[ 756249 ], 10, 1 );
    const_tuple_db9a981db24a26ea90b278665de2841d_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 756259 ], 321 );
    const_str_plain__g5 = UNSTREAM_STRING_ASCII( &constant_bin[ 756580 ], 3, 1 );
    const_str_plain_ocean = UNSTREAM_STRING_ASCII( &constant_bin[ 756583 ], 5, 1 );
    const_dict_ac09b61043b30f22f2e956405ad79658 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 756588 ], 2906 );
    const_str_plain__RdGy_data = UNSTREAM_STRING_ASCII( &constant_bin[ 759494 ], 10, 1 );
    const_str_plain__g6 = UNSTREAM_STRING_ASCII( &constant_bin[ 759504 ], 3, 1 );
    const_str_plain_YlOrBr = UNSTREAM_STRING_ASCII( &constant_bin[ 759507 ], 6, 1 );
    const_dict_8f097861f42f3010bd8f6de6022ffc3c = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 759513 ], 229 );
    const_str_plain__brg_data = UNSTREAM_STRING_ASCII( &constant_bin[ 759742 ], 9, 1 );
    const_str_plain__g12 = UNSTREAM_STRING_ASCII( &constant_bin[ 759751 ], 4, 1 );
    const_str_plain__g26 = UNSTREAM_STRING_ASCII( &constant_bin[ 759755 ], 4, 1 );
    const_str_plain__gist_gray_data = UNSTREAM_STRING_ASCII( &constant_bin[ 759759 ], 15, 1 );
    const_str_plain_OrRd = UNSTREAM_STRING_ASCII( &constant_bin[ 759774 ], 4, 1 );
    const_str_plain_tab10 = UNSTREAM_STRING_ASCII( &constant_bin[ 759778 ], 5, 1 );
    const_str_digest_0870d49f1cf88348cb56a7f4adc73408 = UNSTREAM_STRING_ASCII( &constant_bin[ 759783 ], 62, 0 );
    const_str_plain_gist_stern = UNSTREAM_STRING_ASCII( &constant_bin[ 759845 ], 10, 1 );
    const_str_plain__g22 = UNSTREAM_STRING_ASCII( &constant_bin[ 759855 ], 4, 1 );
    const_str_plain__gist_heat_green = UNSTREAM_STRING_ASCII( &constant_bin[ 759859 ], 16, 1 );
    const_str_plain__Pastel1_data = UNSTREAM_STRING_ASCII( &constant_bin[ 759875 ], 13, 1 );
    const_tuple_ac83b7f87b65db8bc61c88a0c684aae6_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 759888 ], 263 );
    const_str_plain__flag_red = UNSTREAM_STRING_ASCII( &constant_bin[ 760151 ], 9, 1 );
    const_str_plain__BuPu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 760160 ], 10, 1 );
    const_str_plain_PuBu = UNSTREAM_STRING_ASCII( &constant_bin[ 760170 ], 4, 1 );
    const_str_plain__g23 = UNSTREAM_STRING_ASCII( &constant_bin[ 760174 ], 4, 1 );
    const_tuple_a1c2e0d0fdb72592d26c53db2b423104_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 760178 ], 321 );
    const_str_plain__autumn_data = UNSTREAM_STRING_ASCII( &constant_bin[ 760499 ], 12, 1 );
    const_str_plain__g16 = UNSTREAM_STRING_ASCII( &constant_bin[ 760511 ], 4, 1 );
    const_str_plain__BuGn_data = UNSTREAM_STRING_ASCII( &constant_bin[ 760515 ], 10, 1 );
    const_str_plain__g9 = UNSTREAM_STRING_ASCII( &constant_bin[ 760525 ], 3, 1 );
    const_str_plain__bwr_data = UNSTREAM_STRING_ASCII( &constant_bin[ 760528 ], 9, 1 );
    const_str_plain__CMRmap_data = UNSTREAM_STRING_ASCII( &constant_bin[ 760537 ], 12, 1 );
    const_dict_13dcc09e8b14458a914dc22a80eeee13 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 760549 ], 470 );
    const_str_plain__g4 = UNSTREAM_STRING_ASCII( &constant_bin[ 761019 ], 3, 1 );
    const_dict_1b20bf7e6394a197db2b925f2ae9f1f2 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 761022 ], 5594 );
    const_str_plain_gist_heat = UNSTREAM_STRING_ASCII( &constant_bin[ 759860 ], 9, 1 );
    const_str_digest_1ef270d0d79fb0bf55f236f47bc46446 = UNSTREAM_STRING_ASCII( &constant_bin[ 766616 ], 17, 0 );
    const_tuple_dbd02ca2a43f79960ecaa20263657c10_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 766633 ], 263 );
    const_str_plain__gist_earth_data = UNSTREAM_STRING_ASCII( &constant_bin[ 766896 ], 16, 1 );
    const_str_plain__tab20_data = UNSTREAM_STRING_ASCII( &constant_bin[ 766912 ], 11, 1 );
    const_str_plain_terrain = UNSTREAM_STRING_ASCII( &constant_bin[ 766923 ], 7, 1 );
    const_str_plain__Oranges_data = UNSTREAM_STRING_ASCII( &constant_bin[ 766930 ], 13, 1 );
    const_float_minus_1_1 = UNSTREAM_FLOAT( &constant_bin[ 766943 ] );
    const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 0, const_str_plain_gamma ); Py_INCREF( const_str_plain_gamma );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 1, const_str_plain_s ); Py_INCREF( const_str_plain_s );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 2, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 3, const_str_plain_h ); Py_INCREF( const_str_plain_h );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 4, const_str_plain_p0 ); Py_INCREF( const_str_plain_p0 );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 5, const_str_plain_p1 ); Py_INCREF( const_str_plain_p1 );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 6, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 7, const_str_plain_xg ); Py_INCREF( const_str_plain_xg );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 8, const_str_plain_a ); Py_INCREF( const_str_plain_a );
    PyTuple_SET_ITEM( const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 9, const_str_plain_phi ); Py_INCREF( const_str_plain_phi );
    const_dict_7ba6c40e971dab085fcf28da729f7167 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 766951 ], 1215 );
    const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple, 0, const_float_1_0 ); Py_INCREF( const_float_1_0 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple, 1, const_float_0_5 ); Py_INCREF( const_float_0_5 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple, 2, const_float_minus_1_5 ); Py_INCREF( const_float_minus_1_5 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple, 3, const_float_1_0 ); Py_INCREF( const_float_1_0 );
    const_str_plain__ch_helper = UNSTREAM_STRING_ASCII( &constant_bin[ 768166 ], 10, 1 );
    const_tuple_9e6a97cefbfc93e4dbd6fe4790754edf_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 768176 ], 263 );
    const_str_plain__afmhot_data = UNSTREAM_STRING_ASCII( &constant_bin[ 768439 ], 12, 1 );
    const_float_20_9 = UNSTREAM_FLOAT( &constant_bin[ 768451 ] );
    const_str_plain_gnuplot = UNSTREAM_STRING_ASCII( &constant_bin[ 768459 ], 7, 1 );
    const_str_plain__YlOrBr_data = UNSTREAM_STRING_ASCII( &constant_bin[ 768466 ], 12, 1 );
    const_str_plain__tab20c_data = UNSTREAM_STRING_ASCII( &constant_bin[ 768478 ], 12, 1 );
    const_str_plain_tab20 = UNSTREAM_STRING_ASCII( &constant_bin[ 766913 ], 5, 1 );
    const_str_plain_Pastel1 = UNSTREAM_STRING_ASCII( &constant_bin[ 759876 ], 7, 1 );
    const_str_plain_coolwarm = UNSTREAM_STRING_ASCII( &constant_bin[ 768490 ], 8, 1 );
    const_str_plain_Set3 = UNSTREAM_STRING_ASCII( &constant_bin[ 768498 ], 4, 1 );
    const_str_plain__cool_data = UNSTREAM_STRING_ASCII( &constant_bin[ 768502 ], 10, 1 );
    const_str_plain__prism_green = UNSTREAM_STRING_ASCII( &constant_bin[ 768512 ], 12, 1 );
    const_str_plain__prism_red = UNSTREAM_STRING_ASCII( &constant_bin[ 768524 ], 10, 1 );
    const_tuple_9b04358fc83d8c29f6d13e55a485e086_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 768534 ], 321 );
    const_tuple_e22ad1a6fd2b90375e84cff21f64303a_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 768855 ], 321 );
    const_str_plain__g19 = UNSTREAM_STRING_ASCII( &constant_bin[ 769176 ], 4, 1 );
    const_tuple_ef7272d3c529510edf3b0815822dbaa3_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 769180 ], 582 );
    const_dict_46fdda9c2313b830d68498039918be48 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 769762 ], 809 );
    const_tuple_122f654ebd563953484696204c943f8b_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 770571 ], 263 );
    const_str_plain_gist_yarg = UNSTREAM_STRING_ASCII( &constant_bin[ 756226 ], 9, 1 );
    const_str_plain__gnuplot2_data = UNSTREAM_STRING_ASCII( &constant_bin[ 770834 ], 14, 1 );
    const_dict_26510cda7d1dc75818c57eac9563d1d1 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 770848 ], 292 );
    const_str_plain__g13 = UNSTREAM_STRING_ASCII( &constant_bin[ 771140 ], 4, 1 );
    const_tuple_6eb90b29c730cddab6ab1d936156a49c_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 771144 ], 263 );
    const_str_plain__g31 = UNSTREAM_STRING_ASCII( &constant_bin[ 771407 ], 4, 1 );
    const_tuple_de81471e775d0db13ccc93277369c0bb_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 771411 ], 263 );
    const_str_plain__flag_green = UNSTREAM_STRING_ASCII( &constant_bin[ 771674 ], 11, 1 );
    const_tuple_2a4c4f5b12a7944706ab0b855d978f15_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 771685 ], 321 );
    const_tuple_4d8a3db908fea5ac787eae57a231d107_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 772006 ], 263 );
    const_int_pos_33 = PyLong_FromUnsignedLong( 33ul );
    const_tuple_fb0dd03a0e957d10a507ea76b9c3ad27_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 772269 ], 321 );
    const_str_plain__g30 = UNSTREAM_STRING_ASCII( &constant_bin[ 772590 ], 4, 1 );
    const_str_plain_gist_gray = UNSTREAM_STRING_ASCII( &constant_bin[ 759760 ], 9, 1 );
    const_tuple_1cf08670e58213d33381f121283ddef7_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 772594 ], 263 );
    const_str_plain__seismic_data = UNSTREAM_STRING_ASCII( &constant_bin[ 772857 ], 13, 1 );
    const_str_plain__gist_yarg = UNSTREAM_STRING_ASCII( &constant_bin[ 756225 ], 10, 1 );
    const_str_plain__PRGn_data = UNSTREAM_STRING_ASCII( &constant_bin[ 772870 ], 10, 1 );
    const_str_plain_RdGy = UNSTREAM_STRING_ASCII( &constant_bin[ 759495 ], 4, 1 );
    const_str_plain__bone_data = UNSTREAM_STRING_ASCII( &constant_bin[ 772880 ], 10, 1 );
    const_str_plain_Paired = UNSTREAM_STRING_ASCII( &constant_bin[ 772890 ], 6, 1 );
    const_str_plain__g0 = UNSTREAM_STRING_ASCII( &constant_bin[ 772896 ], 3, 1 );
    const_str_plain__g15 = UNSTREAM_STRING_ASCII( &constant_bin[ 772899 ], 4, 1 );
    const_str_plain__winter_data = UNSTREAM_STRING_ASCII( &constant_bin[ 772903 ], 12, 1 );
    const_str_plain_bwr = UNSTREAM_STRING_ASCII( &constant_bin[ 760529 ], 3, 1 );
    const_str_plain__Set1_data = UNSTREAM_STRING_ASCII( &constant_bin[ 772915 ], 10, 1 );
    const_float_minus_0_29227 = UNSTREAM_FLOAT( &constant_bin[ 772925 ] );
    const_str_plain__g2 = UNSTREAM_STRING_ASCII( &constant_bin[ 759755 ], 3, 1 );
    const_dict_61e4a4a8cd2b4181694d4cfb1751640d = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 772933 ], 200 );
    const_str_plain_Set1 = UNSTREAM_STRING_ASCII( &constant_bin[ 772916 ], 4, 1 );
    const_str_plain__gist_heat_data = UNSTREAM_STRING_ASCII( &constant_bin[ 773133 ], 15, 1 );
    const_str_plain_YlGn = UNSTREAM_STRING_ASCII( &constant_bin[ 755980 ], 4, 1 );
    const_str_plain__BrBG_data = UNSTREAM_STRING_ASCII( &constant_bin[ 773148 ], 10, 1 );
    const_str_plain_gfunc = UNSTREAM_STRING_ASCII( &constant_bin[ 773158 ], 5, 1 );
    const_tuple_13493111d1a4f8c8a058ebd7f95c09b1_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 773163 ], 263 );
    const_tuple_9fa91c64747bb6ff4492053856cc06e7_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 773426 ], 234 );
    const_str_plain__Set3_data = UNSTREAM_STRING_ASCII( &constant_bin[ 773660 ], 10, 1 );
    const_str_plain__terrain_data = UNSTREAM_STRING_ASCII( &constant_bin[ 773670 ], 13, 1 );
    const_dict_a6becc14d04a47becd62ae70b4c4482c = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 773683 ], 200 );
    const_str_plain__Purples_data = UNSTREAM_STRING_ASCII( &constant_bin[ 773883 ], 13, 1 );
    const_dict_79ecbf763b054a3ad895cae3fb89c58e = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 773896 ], 152 );
    const_tuple_d6bde7eec8df9cf0ee10c9abbaa88fc9_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 774048 ], 234 );
    const_str_plain_PRGn = UNSTREAM_STRING_ASCII( &constant_bin[ 772871 ], 4, 1 );
    const_tuple_float_0_5_float_0_0_float_0_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_float_0_5_float_0_0_float_0_0_tuple, 0, const_float_0_5 ); Py_INCREF( const_float_0_5 );
    PyTuple_SET_ITEM( const_tuple_float_0_5_float_0_0_float_0_0_tuple, 1, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_5_float_0_0_float_0_0_tuple, 2, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    const_str_plain__gist_rainbow_data = UNSTREAM_STRING_ASCII( &constant_bin[ 774282 ], 18, 1 );
    const_dict_cc81f270cbb7633b5af45d15d4c591ec = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 774300 ], 1389 );
    const_str_plain_RdYlGn = UNSTREAM_STRING_ASCII( &constant_bin[ 775689 ], 6, 1 );
    const_float_1_97294 = UNSTREAM_FLOAT( &constant_bin[ 775695 ] );
    const_str_digest_36fea1563816aa379d3cd2c1ac36c445 = UNSTREAM_STRING_ASCII( &constant_bin[ 775703 ], 23, 0 );
    const_str_plain_gnuplot2 = UNSTREAM_STRING_ASCII( &constant_bin[ 770835 ], 8, 1 );
    const_tuple_float_0_0_float_0_0_float_0_3_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_0_0_float_0_3_tuple, 0, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_0_0_float_0_3_tuple, 1, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_0_0_float_0_3_tuple, 2, const_float_0_3 ); Py_INCREF( const_float_0_3 );
    const_str_digest_0ec62d994d1e365c7efad4dabaaba134 = UNSTREAM_STRING_ASCII( &constant_bin[ 775726 ], 255, 0 );
    const_str_plain_Oranges = UNSTREAM_STRING_ASCII( &constant_bin[ 766931 ], 7, 1 );
    const_float_0_78125 = UNSTREAM_FLOAT( &constant_bin[ 757327 ] );
    const_str_plain__prism_data = UNSTREAM_STRING_ASCII( &constant_bin[ 775981 ], 11, 1 );
    const_dict_e5f8cd4b8b884f01b9dbdb6c0cf95972 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 775992 ], 1862 );
    const_str_plain__Spectral_data = UNSTREAM_STRING_ASCII( &constant_bin[ 777854 ], 14, 1 );
    const_str_plain__g36 = UNSTREAM_STRING_ASCII( &constant_bin[ 777868 ], 4, 1 );
    const_xrange_0_37 = BUILTIN_XRANGE3( const_int_0, const_int_pos_37, const_int_pos_1 );
    const_tuple_b84fc382b1c73eb24052e00184983189_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 777872 ], 350 );
    const_str_plain__YlGn_data = UNSTREAM_STRING_ASCII( &constant_bin[ 778222 ], 10, 1 );
    const_str_plain__g21 = UNSTREAM_STRING_ASCII( &constant_bin[ 778232 ], 4, 1 );
    const_str_plain__copper_data = UNSTREAM_STRING_ASCII( &constant_bin[ 778236 ], 12, 1 );
    const_tuple_4f66db73ea9fdbfdceb9e620df1e4919_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 778248 ], 263 );
    const_str_plain_Purples = UNSTREAM_STRING_ASCII( &constant_bin[ 773884 ], 7, 1 );
    const_tuple_20bd1f5c0a0f9a93d11e666cd7289af4_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 778511 ], 321 );
    const_str_plain__summer_data = UNSTREAM_STRING_ASCII( &constant_bin[ 778832 ], 12, 1 );
    const_str_plain__RdYlGn_data = UNSTREAM_STRING_ASCII( &constant_bin[ 778844 ], 12, 1 );
    const_tuple_8a21be97bcec74887e2b70da615f70d9_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 778856 ], 263 );
    const_tuple_440d7807917857d4ae4d4cd0c76093e7_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 779119 ], 321 );
    const_str_plain_Greys = UNSTREAM_STRING_ASCII( &constant_bin[ 779440 ], 5, 1 );
    const_tuple_194951aabc8c4d0f914fa1c18e921dac_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 779445 ], 263 );
    const_str_plain__g28 = UNSTREAM_STRING_ASCII( &constant_bin[ 779708 ], 4, 1 );
    const_str_plain_YlGnBu = UNSTREAM_STRING_ASCII( &constant_bin[ 755980 ], 6, 1 );
    const_tuple_58dec871a15dc46004a9c29f566fd8e9_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 779712 ], 292 );
    const_str_plain_PiYG = UNSTREAM_STRING_ASCII( &constant_bin[ 756000 ], 4, 1 );
    const_str_plain_seismic = UNSTREAM_STRING_ASCII( &constant_bin[ 772858 ], 7, 1 );
    const_str_plain__Greens_data = UNSTREAM_STRING_ASCII( &constant_bin[ 780004 ], 12, 1 );
    const_dict_e67366b36b736b2b1824e4124103e620 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 780016 ], 316 );
    const_str_plain_gist_earth = UNSTREAM_STRING_ASCII( &constant_bin[ 766897 ], 10, 1 );
    const_str_plain__Reds_data = UNSTREAM_STRING_ASCII( &constant_bin[ 780332 ], 10, 1 );
    const_str_plain__gist_stern_data = UNSTREAM_STRING_ASCII( &constant_bin[ 780342 ], 16, 1 );
    const_str_plain__nipy_spectral_data = UNSTREAM_STRING_ASCII( &constant_bin[ 780358 ], 19, 1 );
    const_str_plain__tab20b_data = UNSTREAM_STRING_ASCII( &constant_bin[ 780377 ], 12, 1 );
    const_str_plain_CMRmap = UNSTREAM_STRING_ASCII( &constant_bin[ 760538 ], 6, 1 );
    const_str_plain_PuBuGn = UNSTREAM_STRING_ASCII( &constant_bin[ 780389 ], 6, 1 );
    const_str_plain__PuOr_data = UNSTREAM_STRING_ASCII( &constant_bin[ 780395 ], 10, 1 );
    const_tuple_7eb55817b097308a4aa82a88a7a374a0_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 780405 ], 263 );
    const_dict_139fa967a21793ecdbc3e590120916a2 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 780668 ], 200 );
    const_float_0_92 = UNSTREAM_FLOAT( &constant_bin[ 780868 ] );
    const_str_plain__g25 = UNSTREAM_STRING_ASCII( &constant_bin[ 780876 ], 4, 1 );
    const_tuple_d09dc699a96e56cc6c61b2a9d13ae443_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 780880 ], 322 );
    const_str_plain__rainbow_data = UNSTREAM_STRING_ASCII( &constant_bin[ 774287 ], 13, 1 );
    const_str_plain__g27 = UNSTREAM_STRING_ASCII( &constant_bin[ 781202 ], 4, 1 );
    const_str_plain__gist_heat_blue = UNSTREAM_STRING_ASCII( &constant_bin[ 781206 ], 15, 1 );
    const_str_plain__g24 = UNSTREAM_STRING_ASCII( &constant_bin[ 781221 ], 4, 1 );
    const_float_11_5 = UNSTREAM_FLOAT( &constant_bin[ 781225 ] );
    const_tuple_6430e1188db9556163de382028b9d704_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 781233 ], 234 );
    const_tuple_float_0_0_float_0_0_float_1_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_0_0_float_1_0_tuple, 0, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_0_0_float_1_0_tuple, 1, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_0_0_float_1_0_tuple, 2, const_float_1_0 ); Py_INCREF( const_float_1_0 );
    const_str_plain_PuRd = UNSTREAM_STRING_ASCII( &constant_bin[ 781467 ], 4, 1 );
    const_str_plain_RdBu = UNSTREAM_STRING_ASCII( &constant_bin[ 781471 ], 4, 1 );
    const_str_plain__spring_data = UNSTREAM_STRING_ASCII( &constant_bin[ 781475 ], 12, 1 );
    const_dict_a065b631920800bd13e7ea9419838858 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 781487 ], 722 );
    const_str_plain__g17 = UNSTREAM_STRING_ASCII( &constant_bin[ 782209 ], 4, 1 );
    const_str_digest_f73618ed65447e45c026300593ea43e2 = UNSTREAM_STRING_ASCII( &constant_bin[ 782213 ], 4, 0 );
    const_str_plain_PuOr = UNSTREAM_STRING_ASCII( &constant_bin[ 780396 ], 4, 1 );
    const_str_plain__Paired_data = UNSTREAM_STRING_ASCII( &constant_bin[ 782217 ], 12, 1 );
    const_str_plain__hsv_data = UNSTREAM_STRING_ASCII( &constant_bin[ 782229 ], 9, 1 );
    const_str_plain__RdBu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 782238 ], 10, 1 );
    const_tuple_d0062c44ff73c1c48f3f7d27f6672421_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 782248 ], 321 );
    const_float_31_5 = UNSTREAM_FLOAT( &constant_bin[ 782569 ] );
    const_tuple_259735cef93a8d5cd32533f90f8ce8d3_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 782577 ], 263 );
    const_str_plain_Wistia = UNSTREAM_STRING_ASCII( &constant_bin[ 782840 ], 6, 1 );
    const_float_minus_0_14861 = UNSTREAM_FLOAT( &constant_bin[ 782846 ] );
    const_str_plain__binary_data = UNSTREAM_STRING_ASCII( &constant_bin[ 782854 ], 12, 1 );
    const_dict_fd4a49377d1d658f7d30b821b6352628 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 782866 ], 366 );
    const_tuple_float_0_0_float_1_0_float_0_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_1_0_float_0_0_tuple, 0, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_1_0_float_0_0_tuple, 1, const_float_1_0 ); Py_INCREF( const_float_1_0 );
    PyTuple_SET_ITEM( const_tuple_float_0_0_float_1_0_float_0_0_tuple, 2, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    const_tuple_391173ce944bd5a033152d725addac81_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 783232 ], 582 );
    const_str_plain__g10 = UNSTREAM_STRING_ASCII( &constant_bin[ 783814 ], 4, 1 );
    const_tuple_dd7b62811603d0af86732a1f25835a50_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 783818 ], 234 );
    const_str_plain_Greens = UNSTREAM_STRING_ASCII( &constant_bin[ 780005 ], 6, 1 );
    const_str_plain__ocean_data = UNSTREAM_STRING_ASCII( &constant_bin[ 784052 ], 11, 1 );
    const_str_plain__prism_blue = UNSTREAM_STRING_ASCII( &constant_bin[ 784063 ], 11, 1 );
    const_str_plain__g20 = UNSTREAM_STRING_ASCII( &constant_bin[ 784074 ], 4, 1 );
    const_str_plain__RdPu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 784078 ], 10, 1 );
    const_str_plain__g14 = UNSTREAM_STRING_ASCII( &constant_bin[ 784088 ], 4, 1 );
    const_str_plain__tab10_data = UNSTREAM_STRING_ASCII( &constant_bin[ 784092 ], 11, 1 );
    const_tuple_cc9102d236a92569966c4ebd4c8fbcf5_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 784103 ], 263 );
    const_tuple_b19a69e04a28b726d8b7d59807ef8eef_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 784366 ], 263 );
    const_str_plain__g8 = UNSTREAM_STRING_ASCII( &constant_bin[ 784629 ], 3, 1 );
    const_str_plain__PuBu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 784632 ], 10, 1 );
    const_tuple_2fe5f075a061fd18cc310f1b06eb16ae_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 784642 ], 350 );
    const_str_plain_Reds = UNSTREAM_STRING_ASCII( &constant_bin[ 780333 ], 4, 1 );
    const_str_plain__g11 = UNSTREAM_STRING_ASCII( &constant_bin[ 784992 ], 4, 1 );
    const_tuple_16581877f4601a2ddb7154cb6281285a_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 784996 ], 263 );
    const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple, 0, const_tuple_float_0_0_float_0_0_float_0_3_tuple ); Py_INCREF( const_tuple_float_0_0_float_0_0_float_0_3_tuple );
    PyTuple_SET_ITEM( const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple, 1, const_tuple_float_0_0_float_0_0_float_1_0_tuple ); Py_INCREF( const_tuple_float_0_0_float_0_0_float_1_0_tuple );
    PyTuple_SET_ITEM( const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple, 2, const_tuple_float_1_0_float_1_0_float_1_0_tuple ); Py_INCREF( const_tuple_float_1_0_float_1_0_float_1_0_tuple );
    const_tuple_float_1_0_float_0_0_float_0_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_0_float_0_0_tuple, 0, const_float_1_0 ); Py_INCREF( const_float_1_0 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_0_float_0_0_tuple, 1, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_float_1_0_float_0_0_float_0_0_tuple, 2, const_float_0_0 ); Py_INCREF( const_float_0_0 );
    PyTuple_SET_ITEM( const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple, 3, const_tuple_float_1_0_float_0_0_float_0_0_tuple ); Py_INCREF( const_tuple_float_1_0_float_0_0_float_0_0_tuple );
    PyTuple_SET_ITEM( const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple, 4, const_tuple_float_0_5_float_0_0_float_0_0_tuple ); Py_INCREF( const_tuple_float_0_5_float_0_0_float_0_0_tuple );
    const_tuple_eb5d9c64a7345357330502cba765a133_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 785259 ], 263 );
    const_float_0_32 = UNSTREAM_FLOAT( &constant_bin[ 785522 ] );
    const_tuple_db58afb74f702702860a0cdf1356a649_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 785530 ], 263 );
    const_str_plain__g35 = UNSTREAM_STRING_ASCII( &constant_bin[ 785793 ], 4, 1 );
    const_str_plain_brg = UNSTREAM_STRING_ASCII( &constant_bin[ 759743 ], 3, 1 );
    const_str_plain__flag_blue = UNSTREAM_STRING_ASCII( &constant_bin[ 785797 ], 10, 1 );
    const_tuple_3f501f1fed43a18bc40d5702c0cd69db_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 785807 ], 263 );
    const_str_plain__Blues_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786070 ], 11, 1 );
    const_str_plain_afmhot = UNSTREAM_STRING_ASCII( &constant_bin[ 768440 ], 6, 1 );
    const_str_plain__PuRd_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786081 ], 10, 1 );
    const_str_plain_BuPu = UNSTREAM_STRING_ASCII( &constant_bin[ 760161 ], 4, 1 );
    const_str_plain__g34 = UNSTREAM_STRING_ASCII( &constant_bin[ 786091 ], 4, 1 );
    const_str_plain__Set2_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786095 ], 10, 1 );
    const_str_plain_Pastel2 = UNSTREAM_STRING_ASCII( &constant_bin[ 786105 ], 7, 1 );
    const_str_plain_GnBu = UNSTREAM_STRING_ASCII( &constant_bin[ 755982 ], 4, 1 );
    const_str_plain__PuBuGn_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786112 ], 12, 1 );
    const_str_plain__YlOrRd_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786124 ], 12, 1 );
    const_str_plain__Greys_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786136 ], 11, 1 );
    const_str_plain_gist_rainbow = UNSTREAM_STRING_ASCII( &constant_bin[ 774283 ], 12, 1 );
    const_tuple_str_plain_x_str_plain_ret_str_plain_m_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_ret_str_plain_m_tuple, 0, const_str_plain_x ); Py_INCREF( const_str_plain_x );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_ret_str_plain_m_tuple, 1, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    PyTuple_SET_ITEM( const_tuple_str_plain_x_str_plain_ret_str_plain_m_tuple, 2, const_str_plain_m ); Py_INCREF( const_str_plain_m );
    const_str_plain_gist_ncar = UNSTREAM_STRING_ASCII( &constant_bin[ 786147 ], 9, 1 );
    const_str_plain__g29 = UNSTREAM_STRING_ASCII( &constant_bin[ 786156 ], 4, 1 );
    const_str_plain__gray_data = UNSTREAM_STRING_ASCII( &constant_bin[ 759764 ], 10, 1 );
    const_str_plain__gnuplot_data = UNSTREAM_STRING_ASCII( &constant_bin[ 786160 ], 13, 1 );
    const_str_plain_tab20c = UNSTREAM_STRING_ASCII( &constant_bin[ 768479 ], 6, 1 );
    const_str_digest_68bcfeed91a2fbe6bb71f773db17210e = UNSTREAM_STRING_ASCII( &constant_bin[ 786173 ], 2036, 0 );
    const_str_plain__g3 = UNSTREAM_STRING_ASCII( &constant_bin[ 755975 ], 3, 1 );
    const_str_plain__pink_data = UNSTREAM_STRING_ASCII( &constant_bin[ 788209 ], 10, 1 );
    const_dict_61b96e51e18659e8ba92a9cb886c68eb = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 788219 ], 200 );
    const_str_plain_Blues = UNSTREAM_STRING_ASCII( &constant_bin[ 786071 ], 5, 1 );
    const_str_plain_rainbow = UNSTREAM_STRING_ASCII( &constant_bin[ 774288 ], 7, 1 );
    const_str_plain_cubehelix = UNSTREAM_STRING_ASCII( &constant_bin[ 759824 ], 9, 1 );
    const_tuple_2bea485d544db289d067c788ebf78b62_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_2bea485d544db289d067c788ebf78b62_tuple, 0, const_tuple_float_0_0_float_0_0_float_1_0_tuple ); Py_INCREF( const_tuple_float_0_0_float_0_0_float_1_0_tuple );
    PyTuple_SET_ITEM( const_tuple_2bea485d544db289d067c788ebf78b62_tuple, 1, const_tuple_float_1_0_float_1_0_float_1_0_tuple ); Py_INCREF( const_tuple_float_1_0_float_1_0_float_1_0_tuple );
    PyTuple_SET_ITEM( const_tuple_2bea485d544db289d067c788ebf78b62_tuple, 2, const_tuple_float_1_0_float_0_0_float_0_0_tuple ); Py_INCREF( const_tuple_float_1_0_float_0_0_float_0_0_tuple );
    const_dict_d876a613e78a88b4cea47cbcba7077b2 = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 788419 ], 316 );
    const_str_plain__hot_data = UNSTREAM_STRING_ASCII( &constant_bin[ 788735 ], 9, 1 );
    const_str_plain__g7 = UNSTREAM_STRING_ASCII( &constant_bin[ 788744 ], 3, 1 );
    const_tuple_6e6f4e9a37231f81f1e456047fd8c742_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 788747 ], 242 );
    const_str_plain_YlOrRd = UNSTREAM_STRING_ASCII( &constant_bin[ 786125 ], 6, 1 );
    const_float_0_84 = UNSTREAM_FLOAT( &constant_bin[ 788989 ] );
    const_str_plain__RdYlBu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 788997 ], 12, 1 );
    const_str_plain__cubehelix_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789009 ], 15, 1 );
    const_str_plain__Pastel2_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789024 ], 13, 1 );
    const_str_plain__gist_ncar_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789037 ], 15, 1 );
    const_str_plain_tab20b = UNSTREAM_STRING_ASCII( &constant_bin[ 780378 ], 6, 1 );
    const_str_plain__OrRd_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789052 ], 10, 1 );
    const_str_plain__gist_heat_red = UNSTREAM_STRING_ASCII( &constant_bin[ 789062 ], 14, 1 );
    const_str_plain__g18 = UNSTREAM_STRING_ASCII( &constant_bin[ 789076 ], 4, 1 );
    const_tuple_53dc862f8960bed320d0251ce04aeaf0_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 789080 ], 582 );
    const_str_plain__Accent_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789662 ], 12, 1 );
    const_tuple_a22c772c730dca9240495aa06353c5e0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_a22c772c730dca9240495aa06353c5e0_tuple, 0, const_tuple_float_0_0_float_0_0_float_1_0_tuple ); Py_INCREF( const_tuple_float_0_0_float_0_0_float_1_0_tuple );
    PyTuple_SET_ITEM( const_tuple_a22c772c730dca9240495aa06353c5e0_tuple, 1, const_tuple_float_1_0_float_0_0_float_0_0_tuple ); Py_INCREF( const_tuple_float_1_0_float_0_0_float_0_0_tuple );
    PyTuple_SET_ITEM( const_tuple_a22c772c730dca9240495aa06353c5e0_tuple, 2, const_tuple_float_0_0_float_1_0_float_0_0_tuple ); Py_INCREF( const_tuple_float_0_0_float_1_0_float_0_0_tuple );
    const_str_plain__coolwarm_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789674 ], 14, 1 );
    const_str_plain_Set2 = UNSTREAM_STRING_ASCII( &constant_bin[ 786096 ], 4, 1 );
    const_float_minus_0_90649 = UNSTREAM_FLOAT( &constant_bin[ 789688 ] );
    const_str_plain_RdYlBu = UNSTREAM_STRING_ASCII( &constant_bin[ 788998 ], 6, 1 );
    const_str_plain__GnBu_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789696 ], 10, 1 );
    const_str_plain__Dark2_data = UNSTREAM_STRING_ASCII( &constant_bin[ 789706 ], 11, 1 );
    const_str_plain_BrBG = UNSTREAM_STRING_ASCII( &constant_bin[ 773149 ], 4, 1 );
    const_str_plain_Dark2 = UNSTREAM_STRING_ASCII( &constant_bin[ 789707 ], 5, 1 );
    const_str_plain__g1 = UNSTREAM_STRING_ASCII( &constant_bin[ 759751 ], 3, 1 );
    const_str_plain__g32 = UNSTREAM_STRING_ASCII( &constant_bin[ 789717 ], 4, 1 );

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_matplotlib$_cm( void )
{
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_dd80d34bc48fe593d7452b7382f30673;
static PyCodeObject *codeobj_7ca714f50dd5177aff8ddf15c2af89b0;
static PyCodeObject *codeobj_3a3a75eacc017b030677b4c53ee5ee6f;
static PyCodeObject *codeobj_7e91d725aa9c77656e205bb95c4e45a3;
static PyCodeObject *codeobj_660ab78476f77e05f409b81259e4d209;
static PyCodeObject *codeobj_6d0d51622009478bd601df761092ef24;
static PyCodeObject *codeobj_a82d4e3c4a8d0bfd42dc1adc809d58dd;
static PyCodeObject *codeobj_e6941c21b0200fea6ce96161e8b6c66b;
static PyCodeObject *codeobj_55ba6e8ca6ba6f375640e6358def557b;
static PyCodeObject *codeobj_53cd0df449e64d7ea7808a94a38ef665;
static PyCodeObject *codeobj_d63c993436bca5f93a9c78ed99803ff4;
static PyCodeObject *codeobj_2852c7d737084fabc63ea0ea210f2aa2;
static PyCodeObject *codeobj_9029bab7a1cf5f66c45b951f2c14fbb5;
static PyCodeObject *codeobj_27e2261ab6c9abc0e016656ef2877a5e;
static PyCodeObject *codeobj_3eeb63045fca5a861f2fe37fdedc6787;
static PyCodeObject *codeobj_e119297376def3fb48f19b5a35d19efc;
static PyCodeObject *codeobj_4073d3ca4fbe497a448f547e8ecc72d7;
static PyCodeObject *codeobj_8a3cccd29b4301344b470b317d475974;
static PyCodeObject *codeobj_dada2ba6b2296647be70d287d912eefa;
static PyCodeObject *codeobj_b5d521e44c58af8e9d25ee8f3491d39e;
static PyCodeObject *codeobj_3f141603091f9e79166fc67462636516;
static PyCodeObject *codeobj_71be7a18f282021ca0991601b42aca58;
static PyCodeObject *codeobj_24fee38c9e266482a2e45eea3fe5f704;
static PyCodeObject *codeobj_93f63737e8d01a5e712320109901c660;
static PyCodeObject *codeobj_9a049aa6ab7d4ac8f3db952c101016b3;
static PyCodeObject *codeobj_59430b3c1d9efa7f67144ba688bce895;
static PyCodeObject *codeobj_2e9d0097cf3c6357824a05b9a838d1ef;
static PyCodeObject *codeobj_560516ef25ad4926357a26fe2e0ee1fe;
static PyCodeObject *codeobj_dab820f0e92ed8284b12269dc4bb5313;
static PyCodeObject *codeobj_d9e99e12619d7acd3a9a38a354b64f8a;
static PyCodeObject *codeobj_6eba6b875aee118971f5958bd375cae4;
static PyCodeObject *codeobj_56c9d341f43b8152629e1d5e5810ecb3;
static PyCodeObject *codeobj_1d722020af9b4fc79a1556ef37f5760e;
static PyCodeObject *codeobj_274d1243a2ef895f960c92b92c710875;
static PyCodeObject *codeobj_a8a16c55fe462d4caf5ee4e050c4e1bf;
static PyCodeObject *codeobj_539df7ba98dcbf44b9cf22062e078c6c;
static PyCodeObject *codeobj_34cdfa0db5a804bed374f3274924c102;
static PyCodeObject *codeobj_5e8fce4fc39e166a2d0361915147e7ca;
static PyCodeObject *codeobj_303af22703fa5d7ab03e56b05a38530a;
static PyCodeObject *codeobj_18b4beebf832bfd38d9855b9aced374d;
static PyCodeObject *codeobj_3eb187db916caa0fb065588428c318c1;
static PyCodeObject *codeobj_3719f9e14b88827afd13fd07c71d8ae1;
static PyCodeObject *codeobj_1c09eff0e45fde6ecde90c7a9f614ba5;
static PyCodeObject *codeobj_82afbaaa67e636aa043c427e7fdb28c5;
static PyCodeObject *codeobj_c425bfa3b697b36da88d800f6a5f649c;
static PyCodeObject *codeobj_3afce450255723e02f6e0c2dfbb37a63;
static PyCodeObject *codeobj_5c7211186caf9b0229bf6a77aa4c1e07;
static PyCodeObject *codeobj_2f98b0c828fcabf21378573c27697830;
static PyCodeObject *codeobj_cd24745a8a3faf93f9e789c7a6bb948f;
static PyCodeObject *codeobj_351882a054fb67563edba00f287e656d;
static PyCodeObject *codeobj_6178e17e4d40750a1307d73e08fbfc0a;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_1ef270d0d79fb0bf55f236f47bc46446 );
    codeobj_dd80d34bc48fe593d7452b7382f30673 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_dictcontraction, 160, const_tuple_str_plain_i_tuple, 1, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ca714f50dd5177aff8ddf15c2af89b0 = MAKE_CODEOBJ( module_filename_obj, const_str_digest_36fea1563816aa379d3cd2c1ac36c445, 1, const_tuple_empty, 0, 0, CO_NOFREE );
    codeobj_3a3a75eacc017b030677b4c53ee5ee6f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__ch_helper, 56, const_tuple_a8e4d90ae8ea456e67dffd07b85de560_tuple, 7, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7e91d725aa9c77656e205bb95c4e45a3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__flag_blue, 48, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_660ab78476f77e05f409b81259e4d209 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__flag_green, 47, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6d0d51622009478bd601df761092ef24 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__flag_red, 46, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a82d4e3c4a8d0bfd42dc1adc809d58dd = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g0, 114, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e6941c21b0200fea6ce96161e8b6c66b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g1, 115, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_55ba6e8ca6ba6f375640e6358def557b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g10, 124, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_53cd0df449e64d7ea7808a94a38ef665 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g11, 125, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d63c993436bca5f93a9c78ed99803ff4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g12, 126, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2852c7d737084fabc63ea0ea210f2aa2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g13, 127, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9029bab7a1cf5f66c45b951f2c14fbb5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g14, 128, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_27e2261ab6c9abc0e016656ef2877a5e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g15, 129, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3eeb63045fca5a861f2fe37fdedc6787 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g16, 130, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e119297376def3fb48f19b5a35d19efc = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g17, 131, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4073d3ca4fbe497a448f547e8ecc72d7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g18, 132, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8a3cccd29b4301344b470b317d475974 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g19, 133, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dada2ba6b2296647be70d287d912eefa = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g2, 116, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b5d521e44c58af8e9d25ee8f3491d39e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g20, 134, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3f141603091f9e79166fc67462636516 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g21, 135, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_71be7a18f282021ca0991601b42aca58 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g22, 136, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_24fee38c9e266482a2e45eea3fe5f704 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g23, 137, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_93f63737e8d01a5e712320109901c660 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g24, 138, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9a049aa6ab7d4ac8f3db952c101016b3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g25, 139, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_59430b3c1d9efa7f67144ba688bce895 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g26, 140, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2e9d0097cf3c6357824a05b9a838d1ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g27, 141, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_560516ef25ad4926357a26fe2e0ee1fe = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g28, 142, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dab820f0e92ed8284b12269dc4bb5313 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g29, 143, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d9e99e12619d7acd3a9a38a354b64f8a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g3, 117, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6eba6b875aee118971f5958bd375cae4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g30, 144, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_56c9d341f43b8152629e1d5e5810ecb3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g31, 145, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1d722020af9b4fc79a1556ef37f5760e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g32, 146, const_tuple_str_plain_x_str_plain_ret_str_plain_m_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_274d1243a2ef895f960c92b92c710875 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g33, 155, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a8a16c55fe462d4caf5ee4e050c4e1bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g34, 156, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_539df7ba98dcbf44b9cf22062e078c6c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g35, 157, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_34cdfa0db5a804bed374f3274924c102 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g36, 158, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5e8fce4fc39e166a2d0361915147e7ca = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g4, 118, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_303af22703fa5d7ab03e56b05a38530a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g5, 119, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_18b4beebf832bfd38d9855b9aced374d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g6, 120, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3eb187db916caa0fb065588428c318c1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g7, 121, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3719f9e14b88827afd13fd07c71d8ae1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g8, 122, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1c09eff0e45fde6ecde90c7a9f614ba5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__g9, 123, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_82afbaaa67e636aa043c427e7fdb28c5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__gist_heat_blue, 1009, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c425bfa3b697b36da88d800f6a5f649c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__gist_heat_green, 1008, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3afce450255723e02f6e0c2dfbb37a63 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__gist_heat_red, 1007, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5c7211186caf9b0229bf6a77aa4c1e07 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__gist_yarg, 1088, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f98b0c828fcabf21378573c27697830 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__prism_blue, 53, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cd24745a8a3faf93f9e789c7a6bb948f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__prism_green, 52, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_351882a054fb67563edba00f287e656d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__prism_red, 51, const_tuple_str_plain_x_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6178e17e4d40750a1307d73e08fbfc0a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_cubehelix, 66, const_tuple_str_plain_gamma_str_plain_s_str_plain_r_str_plain_h_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_10__g1(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_11__g2(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_12__g3(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_13__g4(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_14__g5(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_15__g6(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_16__g7(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_17__g8(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_18__g9(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_19__g10(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_1__flag_red(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_20__g11(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_21__g12(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_22__g13(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_23__g14(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_24__g15(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_25__g16(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_26__g17(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_27__g18(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_28__g19(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_29__g20(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_2__flag_green(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_30__g21(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_31__g22(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_32__g23(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_33__g24(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_34__g25(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_35__g26(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_36__g27(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_37__g28(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_38__g29(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_39__g30(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_3__flag_blue(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_40__g31(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_41__g32(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_42__g33(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_43__g34(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_44__g35(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_45__g36(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_46__gist_heat_red(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_47__gist_heat_green(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_48__gist_heat_blue(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_49__gist_yarg(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_4__prism_red(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_5__prism_green(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_6__prism_blue(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_7__ch_helper(  );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_8_cubehelix( PyObject *defaults );


static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_9__g0(  );


// The module function definitions.
static PyObject *impl_matplotlib$_cm$$$function_1__flag_red( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6d0d51622009478bd601df761092ef24;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6d0d51622009478bd601df761092ef24 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6d0d51622009478bd601df761092ef24, codeobj_6d0d51622009478bd601df761092ef24, module_matplotlib$_cm, sizeof(void *) );
    frame_6d0d51622009478bd601df761092ef24 = cache_frame_6d0d51622009478bd601df761092ef24;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6d0d51622009478bd601df761092ef24 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6d0d51622009478bd601df761092ef24 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_left_name_5;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_right_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_right_name_5;
        tmp_left_name_2 = const_float_0_75;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_5 = par_x;
        tmp_right_name_2 = const_float_31_5;
        tmp_left_name_4 = BINARY_OPERATION_MUL_OBJECT_FLOAT( tmp_left_name_5, tmp_right_name_2 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_float_0_25;
        tmp_left_name_3 = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_4, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_4 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );

            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_3, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_3 );
        Py_DECREF( tmp_right_name_4 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_6d0d51622009478bd601df761092ef24->m_frame.f_lineno = 46;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_MUL_FLOAT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_float_0_5;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 46;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d0d51622009478bd601df761092ef24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d0d51622009478bd601df761092ef24 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6d0d51622009478bd601df761092ef24 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6d0d51622009478bd601df761092ef24, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6d0d51622009478bd601df761092ef24->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6d0d51622009478bd601df761092ef24, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6d0d51622009478bd601df761092ef24,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_6d0d51622009478bd601df761092ef24 == cache_frame_6d0d51622009478bd601df761092ef24 )
    {
        Py_DECREF( frame_6d0d51622009478bd601df761092ef24 );
    }
    cache_frame_6d0d51622009478bd601df761092ef24 = NULL;

    assertFrameObject( frame_6d0d51622009478bd601df761092ef24 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_1__flag_red );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_1__flag_red );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_2__flag_green( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_660ab78476f77e05f409b81259e4d209;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_660ab78476f77e05f409b81259e4d209 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_660ab78476f77e05f409b81259e4d209, codeobj_660ab78476f77e05f409b81259e4d209, module_matplotlib$_cm, sizeof(void *) );
    frame_660ab78476f77e05f409b81259e4d209 = cache_frame_660ab78476f77e05f409b81259e4d209;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_660ab78476f77e05f409b81259e4d209 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_660ab78476f77e05f409b81259e4d209 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_float_31_5;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_FLOAT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_660ab78476f77e05f409b81259e4d209->m_frame.f_lineno = 47;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 47;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_660ab78476f77e05f409b81259e4d209 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_660ab78476f77e05f409b81259e4d209 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_660ab78476f77e05f409b81259e4d209 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_660ab78476f77e05f409b81259e4d209, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_660ab78476f77e05f409b81259e4d209->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_660ab78476f77e05f409b81259e4d209, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_660ab78476f77e05f409b81259e4d209,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_660ab78476f77e05f409b81259e4d209 == cache_frame_660ab78476f77e05f409b81259e4d209 )
    {
        Py_DECREF( frame_660ab78476f77e05f409b81259e4d209 );
    }
    cache_frame_660ab78476f77e05f409b81259e4d209 = NULL;

    assertFrameObject( frame_660ab78476f77e05f409b81259e4d209 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_2__flag_green );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_2__flag_green );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_3__flag_blue( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_7e91d725aa9c77656e205bb95c4e45a3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7e91d725aa9c77656e205bb95c4e45a3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7e91d725aa9c77656e205bb95c4e45a3, codeobj_7e91d725aa9c77656e205bb95c4e45a3, module_matplotlib$_cm, sizeof(void *) );
    frame_7e91d725aa9c77656e205bb95c4e45a3 = cache_frame_7e91d725aa9c77656e205bb95c4e45a3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7e91d725aa9c77656e205bb95c4e45a3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7e91d725aa9c77656e205bb95c4e45a3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_left_name_5;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_right_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_right_name_5;
        tmp_left_name_2 = const_float_0_75;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_5 = par_x;
        tmp_right_name_2 = const_float_31_5;
        tmp_left_name_4 = BINARY_OPERATION_MUL_OBJECT_FLOAT( tmp_left_name_5, tmp_right_name_2 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_float_0_25;
        tmp_left_name_3 = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_4, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_4 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );

            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_3, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_3 );
        Py_DECREF( tmp_right_name_4 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_7e91d725aa9c77656e205bb95c4e45a3->m_frame.f_lineno = 48;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_MUL_FLOAT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_float_0_5;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 48;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e91d725aa9c77656e205bb95c4e45a3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e91d725aa9c77656e205bb95c4e45a3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7e91d725aa9c77656e205bb95c4e45a3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7e91d725aa9c77656e205bb95c4e45a3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7e91d725aa9c77656e205bb95c4e45a3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7e91d725aa9c77656e205bb95c4e45a3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7e91d725aa9c77656e205bb95c4e45a3,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_7e91d725aa9c77656e205bb95c4e45a3 == cache_frame_7e91d725aa9c77656e205bb95c4e45a3 )
    {
        Py_DECREF( frame_7e91d725aa9c77656e205bb95c4e45a3 );
    }
    cache_frame_7e91d725aa9c77656e205bb95c4e45a3 = NULL;

    assertFrameObject( frame_7e91d725aa9c77656e205bb95c4e45a3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_3__flag_blue );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_3__flag_blue );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_4__prism_red( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_351882a054fb67563edba00f287e656d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_351882a054fb67563edba00f287e656d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_351882a054fb67563edba00f287e656d, codeobj_351882a054fb67563edba00f287e656d, module_matplotlib$_cm, sizeof(void *) );
    frame_351882a054fb67563edba00f287e656d = cache_frame_351882a054fb67563edba00f287e656d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_351882a054fb67563edba00f287e656d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_351882a054fb67563edba00f287e656d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_left_name_5;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_right_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_right_name_5;
        tmp_left_name_2 = const_float_0_75;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_5 = par_x;
        tmp_right_name_2 = const_float_20_9;
        tmp_left_name_4 = BINARY_OPERATION_MUL_OBJECT_FLOAT( tmp_left_name_5, tmp_right_name_2 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_float_0_25;
        tmp_left_name_3 = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_4, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_4 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );

            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_3, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_3 );
        Py_DECREF( tmp_right_name_4 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_351882a054fb67563edba00f287e656d->m_frame.f_lineno = 51;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_MUL_FLOAT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_float_0_67;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 51;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_351882a054fb67563edba00f287e656d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_351882a054fb67563edba00f287e656d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_351882a054fb67563edba00f287e656d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_351882a054fb67563edba00f287e656d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_351882a054fb67563edba00f287e656d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_351882a054fb67563edba00f287e656d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_351882a054fb67563edba00f287e656d,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_351882a054fb67563edba00f287e656d == cache_frame_351882a054fb67563edba00f287e656d )
    {
        Py_DECREF( frame_351882a054fb67563edba00f287e656d );
    }
    cache_frame_351882a054fb67563edba00f287e656d = NULL;

    assertFrameObject( frame_351882a054fb67563edba00f287e656d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_4__prism_red );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_4__prism_red );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_5__prism_green( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_cd24745a8a3faf93f9e789c7a6bb948f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cd24745a8a3faf93f9e789c7a6bb948f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_cd24745a8a3faf93f9e789c7a6bb948f, codeobj_cd24745a8a3faf93f9e789c7a6bb948f, module_matplotlib$_cm, sizeof(void *) );
    frame_cd24745a8a3faf93f9e789c7a6bb948f = cache_frame_cd24745a8a3faf93f9e789c7a6bb948f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_cd24745a8a3faf93f9e789c7a6bb948f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_cd24745a8a3faf93f9e789c7a6bb948f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_left_name_5;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_right_name_4;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_right_name_5;
        tmp_left_name_2 = const_float_0_75;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_5 = par_x;
        tmp_right_name_2 = const_float_20_9;
        tmp_left_name_4 = BINARY_OPERATION_MUL_OBJECT_FLOAT( tmp_left_name_5, tmp_right_name_2 );
        if ( tmp_left_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_float_0_25;
        tmp_left_name_3 = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_4, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_4 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_3 );

            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_3, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_3 );
        Py_DECREF( tmp_right_name_4 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_cd24745a8a3faf93f9e789c7a6bb948f->m_frame.f_lineno = 52;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_MUL_FLOAT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_float_0_33;
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 52;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd24745a8a3faf93f9e789c7a6bb948f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd24745a8a3faf93f9e789c7a6bb948f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_cd24745a8a3faf93f9e789c7a6bb948f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_cd24745a8a3faf93f9e789c7a6bb948f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_cd24745a8a3faf93f9e789c7a6bb948f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_cd24745a8a3faf93f9e789c7a6bb948f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cd24745a8a3faf93f9e789c7a6bb948f,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_cd24745a8a3faf93f9e789c7a6bb948f == cache_frame_cd24745a8a3faf93f9e789c7a6bb948f )
    {
        Py_DECREF( frame_cd24745a8a3faf93f9e789c7a6bb948f );
    }
    cache_frame_cd24745a8a3faf93f9e789c7a6bb948f = NULL;

    assertFrameObject( frame_cd24745a8a3faf93f9e789c7a6bb948f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_5__prism_green );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_5__prism_green );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_6__prism_blue( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2f98b0c828fcabf21378573c27697830;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2f98b0c828fcabf21378573c27697830 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f98b0c828fcabf21378573c27697830, codeobj_2f98b0c828fcabf21378573c27697830, module_matplotlib$_cm, sizeof(void *) );
    frame_2f98b0c828fcabf21378573c27697830 = cache_frame_2f98b0c828fcabf21378573c27697830;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f98b0c828fcabf21378573c27697830 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f98b0c828fcabf21378573c27697830 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_left_name_1 = const_float_minus_1_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_3 = par_x;
        tmp_right_name_2 = const_float_20_9;
        tmp_left_name_2 = BINARY_OPERATION_MUL_OBJECT_FLOAT( tmp_left_name_3, tmp_right_name_2 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_2 );

            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_2 );
        Py_DECREF( tmp_right_name_3 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_2f98b0c828fcabf21378573c27697830->m_frame.f_lineno = 53;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_right_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION_MUL_FLOAT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 53;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f98b0c828fcabf21378573c27697830 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f98b0c828fcabf21378573c27697830 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f98b0c828fcabf21378573c27697830 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f98b0c828fcabf21378573c27697830, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f98b0c828fcabf21378573c27697830->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f98b0c828fcabf21378573c27697830, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f98b0c828fcabf21378573c27697830,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_2f98b0c828fcabf21378573c27697830 == cache_frame_2f98b0c828fcabf21378573c27697830 )
    {
        Py_DECREF( frame_2f98b0c828fcabf21378573c27697830 );
    }
    cache_frame_2f98b0c828fcabf21378573c27697830 = NULL;

    assertFrameObject( frame_2f98b0c828fcabf21378573c27697830 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_6__prism_blue );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_6__prism_blue );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_7__ch_helper( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_gamma = python_pars[ 0 ];
    PyObject *par_s = python_pars[ 1 ];
    PyObject *par_r = python_pars[ 2 ];
    PyObject *par_h = python_pars[ 3 ];
    PyObject *par_p0 = python_pars[ 4 ];
    PyObject *par_p1 = python_pars[ 5 ];
    PyObject *par_x = python_pars[ 6 ];
    PyObject *var_xg = NULL;
    PyObject *var_a = NULL;
    PyObject *var_phi = NULL;
    struct Nuitka_FrameObject *frame_3a3a75eacc017b030677b4c53ee5ee6f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3a3a75eacc017b030677b4c53ee5ee6f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3a3a75eacc017b030677b4c53ee5ee6f, codeobj_3a3a75eacc017b030677b4c53ee5ee6f, module_matplotlib$_cm, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_3a3a75eacc017b030677b4c53ee5ee6f = cache_frame_3a3a75eacc017b030677b4c53ee5ee6f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3a3a75eacc017b030677b4c53ee5ee6f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3a3a75eacc017b030677b4c53ee5ee6f ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        CHECK_OBJECT( par_gamma );
        tmp_right_name_1 = par_gamma;
        tmp_assign_source_1 = POWER_OPERATION( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 59;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_xg == NULL );
        var_xg = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_left_name_5;
        PyObject *tmp_right_name_4;
        PyObject *tmp_right_name_5;
        CHECK_OBJECT( par_h );
        tmp_left_name_4 = par_h;
        CHECK_OBJECT( var_xg );
        tmp_right_name_2 = var_xg;
        tmp_left_name_3 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_4, tmp_right_name_2 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 62;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_5 = const_int_pos_1;
        CHECK_OBJECT( var_xg );
        tmp_right_name_4 = var_xg;
        tmp_right_name_3 = BINARY_OPERATION_SUB_LONG_OBJECT( tmp_left_name_5, tmp_right_name_4 );
        if ( tmp_right_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_3 );

            exception_lineno = 62;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_3, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_3 );
        Py_DECREF( tmp_right_name_3 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 62;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_int_pos_2;
        tmp_assign_source_2 = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_2, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 62;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_a == NULL );
        var_a = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_left_name_6;
        PyObject *tmp_left_name_7;
        PyObject *tmp_right_name_6;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_right_name_7;
        PyObject *tmp_left_name_8;
        PyObject *tmp_left_name_9;
        PyObject *tmp_right_name_8;
        PyObject *tmp_right_name_9;
        PyObject *tmp_left_name_10;
        PyObject *tmp_right_name_10;
        tmp_left_name_7 = const_int_pos_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_right_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_pi );
        if ( tmp_right_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_6 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_7, tmp_right_name_6 );
        Py_DECREF( tmp_right_name_6 );
        if ( tmp_left_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_s );
        tmp_left_name_9 = par_s;
        tmp_right_name_8 = const_int_pos_3;
        tmp_left_name_8 = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_9, tmp_right_name_8 );
        if ( tmp_left_name_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );

            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_r );
        tmp_left_name_10 = par_r;
        CHECK_OBJECT( par_x );
        tmp_right_name_10 = par_x;
        tmp_right_name_9 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_10, tmp_right_name_10 );
        if ( tmp_right_name_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );
            Py_DECREF( tmp_left_name_8 );

            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_7 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_8, tmp_right_name_9 );
        Py_DECREF( tmp_left_name_8 );
        Py_DECREF( tmp_right_name_9 );
        if ( tmp_right_name_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_6 );

            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_6, tmp_right_name_7 );
        Py_DECREF( tmp_left_name_6 );
        Py_DECREF( tmp_right_name_7 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 63;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert( var_phi == NULL );
        var_phi = tmp_assign_source_3;
    }
    {
        PyObject *tmp_left_name_11;
        PyObject *tmp_right_name_11;
        PyObject *tmp_left_name_12;
        PyObject *tmp_right_name_12;
        PyObject *tmp_left_name_13;
        PyObject *tmp_left_name_14;
        PyObject *tmp_right_name_13;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_right_name_14;
        PyObject *tmp_left_name_15;
        PyObject *tmp_right_name_15;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT( var_xg );
        tmp_left_name_11 = var_xg;
        CHECK_OBJECT( var_a );
        tmp_left_name_12 = var_a;
        CHECK_OBJECT( par_p0 );
        tmp_left_name_14 = par_p0;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( var_phi );
        tmp_args_element_name_1 = var_phi;
        frame_3a3a75eacc017b030677b4c53ee5ee6f->m_frame.f_lineno = 64;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_right_name_13 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_cos, call_args );
        }

        if ( tmp_right_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_13 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_14, tmp_right_name_13 );
        Py_DECREF( tmp_right_name_13 );
        if ( tmp_left_name_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_p1 );
        tmp_left_name_15 = par_p1;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_left_name_13 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_3;
        CHECK_OBJECT( var_phi );
        tmp_args_element_name_2 = var_phi;
        frame_3a3a75eacc017b030677b4c53ee5ee6f->m_frame.f_lineno = 64;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_right_name_15 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_sin, call_args );
        }

        if ( tmp_right_name_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_13 );

            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_14 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_15, tmp_right_name_15 );
        Py_DECREF( tmp_right_name_15 );
        if ( tmp_right_name_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_13 );

            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_12 = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_13, tmp_right_name_14 );
        Py_DECREF( tmp_left_name_13 );
        Py_DECREF( tmp_right_name_14 );
        if ( tmp_right_name_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_11 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_12, tmp_right_name_12 );
        Py_DECREF( tmp_right_name_12 );
        if ( tmp_right_name_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_OBJECT( tmp_left_name_11, tmp_right_name_11 );
        Py_DECREF( tmp_right_name_11 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 64;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a3a75eacc017b030677b4c53ee5ee6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a3a75eacc017b030677b4c53ee5ee6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3a3a75eacc017b030677b4c53ee5ee6f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3a3a75eacc017b030677b4c53ee5ee6f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3a3a75eacc017b030677b4c53ee5ee6f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3a3a75eacc017b030677b4c53ee5ee6f, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3a3a75eacc017b030677b4c53ee5ee6f,
        type_description_1,
        par_gamma,
        par_s,
        par_r,
        par_h,
        par_p0,
        par_p1,
        par_x,
        var_xg,
        var_a,
        var_phi
    );


    // Release cached frame.
    if ( frame_3a3a75eacc017b030677b4c53ee5ee6f == cache_frame_3a3a75eacc017b030677b4c53ee5ee6f )
    {
        Py_DECREF( frame_3a3a75eacc017b030677b4c53ee5ee6f );
    }
    cache_frame_3a3a75eacc017b030677b4c53ee5ee6f = NULL;

    assertFrameObject( frame_3a3a75eacc017b030677b4c53ee5ee6f );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_7__ch_helper );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_gamma );
    Py_DECREF( par_gamma );
    par_gamma = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    CHECK_OBJECT( (PyObject *)par_r );
    Py_DECREF( par_r );
    par_r = NULL;

    CHECK_OBJECT( (PyObject *)par_h );
    Py_DECREF( par_h );
    par_h = NULL;

    CHECK_OBJECT( (PyObject *)par_p0 );
    Py_DECREF( par_p0 );
    par_p0 = NULL;

    CHECK_OBJECT( (PyObject *)par_p1 );
    Py_DECREF( par_p1 );
    par_p1 = NULL;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)var_xg );
    Py_DECREF( var_xg );
    var_xg = NULL;

    CHECK_OBJECT( (PyObject *)var_a );
    Py_DECREF( var_a );
    var_a = NULL;

    CHECK_OBJECT( (PyObject *)var_phi );
    Py_DECREF( var_phi );
    var_phi = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_gamma );
    Py_DECREF( par_gamma );
    par_gamma = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    CHECK_OBJECT( (PyObject *)par_r );
    Py_DECREF( par_r );
    par_r = NULL;

    CHECK_OBJECT( (PyObject *)par_h );
    Py_DECREF( par_h );
    par_h = NULL;

    CHECK_OBJECT( (PyObject *)par_p0 );
    Py_DECREF( par_p0 );
    par_p0 = NULL;

    CHECK_OBJECT( (PyObject *)par_p1 );
    Py_DECREF( par_p1 );
    par_p1 = NULL;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    Py_XDECREF( var_xg );
    var_xg = NULL;

    Py_XDECREF( var_a );
    var_a = NULL;

    Py_XDECREF( var_phi );
    var_phi = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_7__ch_helper );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_8_cubehelix( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_gamma = python_pars[ 0 ];
    PyObject *par_s = python_pars[ 1 ];
    PyObject *par_r = python_pars[ 2 ];
    PyObject *par_h = python_pars[ 3 ];
    struct Nuitka_FrameObject *frame_6178e17e4d40750a1307d73e08fbfc0a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_6178e17e4d40750a1307d73e08fbfc0a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6178e17e4d40750a1307d73e08fbfc0a, codeobj_6178e17e4d40750a1307d73e08fbfc0a, module_matplotlib$_cm, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_6178e17e4d40750a1307d73e08fbfc0a = cache_frame_6178e17e4d40750a1307d73e08fbfc0a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6178e17e4d40750a1307d73e08fbfc0a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6178e17e4d40750a1307d73e08fbfc0a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_args_element_name_11;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        PyObject *tmp_args_element_name_14;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_element_name_15;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_args_element_name_16;
        PyObject *tmp_args_element_name_17;
        PyObject *tmp_args_element_name_18;
        PyObject *tmp_args_element_name_19;
        PyObject *tmp_args_element_name_20;
        PyObject *tmp_args_element_name_21;
        tmp_dict_key_1 = const_str_plain_red;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_partial );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "partial" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 104;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__ch_helper );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ch_helper );
        }

        if ( tmp_mvar_value_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ch_helper" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 104;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_gamma );
        tmp_args_element_name_2 = par_gamma;
        CHECK_OBJECT( par_s );
        tmp_args_element_name_3 = par_s;
        CHECK_OBJECT( par_r );
        tmp_args_element_name_4 = par_r;
        CHECK_OBJECT( par_h );
        tmp_args_element_name_5 = par_h;
        tmp_args_element_name_6 = const_float_minus_0_14861;
        tmp_args_element_name_7 = const_float_1_78277;
        frame_6178e17e4d40750a1307d73e08fbfc0a->m_frame.f_lineno = 104;
        {
            PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
            tmp_dict_value_1 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_1, call_args );
        }

        if ( tmp_dict_value_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 104;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_return_value, tmp_dict_key_1, tmp_dict_value_1 );
        Py_DECREF( tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_green;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_partial );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_return_value );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "partial" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 105;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__ch_helper );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ch_helper );
        }

        if ( tmp_mvar_value_4 == NULL )
        {
            Py_DECREF( tmp_return_value );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ch_helper" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 105;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_8 = tmp_mvar_value_4;
        CHECK_OBJECT( par_gamma );
        tmp_args_element_name_9 = par_gamma;
        CHECK_OBJECT( par_s );
        tmp_args_element_name_10 = par_s;
        CHECK_OBJECT( par_r );
        tmp_args_element_name_11 = par_r;
        CHECK_OBJECT( par_h );
        tmp_args_element_name_12 = par_h;
        tmp_args_element_name_13 = const_float_minus_0_29227;
        tmp_args_element_name_14 = const_float_minus_0_90649;
        frame_6178e17e4d40750a1307d73e08fbfc0a->m_frame.f_lineno = 105;
        {
            PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11, tmp_args_element_name_12, tmp_args_element_name_13, tmp_args_element_name_14 };
            tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_2, call_args );
        }

        if ( tmp_dict_value_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 105;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_return_value, tmp_dict_key_2, tmp_dict_value_2 );
        Py_DECREF( tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_blue;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_partial );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_partial );
        }

        if ( tmp_mvar_value_5 == NULL )
        {
            Py_DECREF( tmp_return_value );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "partial" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 106;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__ch_helper );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ch_helper );
        }

        if ( tmp_mvar_value_6 == NULL )
        {
            Py_DECREF( tmp_return_value );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ch_helper" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 106;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_15 = tmp_mvar_value_6;
        CHECK_OBJECT( par_gamma );
        tmp_args_element_name_16 = par_gamma;
        CHECK_OBJECT( par_s );
        tmp_args_element_name_17 = par_s;
        CHECK_OBJECT( par_r );
        tmp_args_element_name_18 = par_r;
        CHECK_OBJECT( par_h );
        tmp_args_element_name_19 = par_h;
        tmp_args_element_name_20 = const_float_1_97294;
        tmp_args_element_name_21 = const_float_0_0;
        frame_6178e17e4d40750a1307d73e08fbfc0a->m_frame.f_lineno = 106;
        {
            PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18, tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21 };
            tmp_dict_value_3 = CALL_FUNCTION_WITH_ARGS7( tmp_called_name_3, call_args );
        }

        if ( tmp_dict_value_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_return_value );

            exception_lineno = 106;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_return_value, tmp_dict_key_3, tmp_dict_value_3 );
        Py_DECREF( tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6178e17e4d40750a1307d73e08fbfc0a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6178e17e4d40750a1307d73e08fbfc0a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6178e17e4d40750a1307d73e08fbfc0a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6178e17e4d40750a1307d73e08fbfc0a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6178e17e4d40750a1307d73e08fbfc0a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6178e17e4d40750a1307d73e08fbfc0a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6178e17e4d40750a1307d73e08fbfc0a,
        type_description_1,
        par_gamma,
        par_s,
        par_r,
        par_h
    );


    // Release cached frame.
    if ( frame_6178e17e4d40750a1307d73e08fbfc0a == cache_frame_6178e17e4d40750a1307d73e08fbfc0a )
    {
        Py_DECREF( frame_6178e17e4d40750a1307d73e08fbfc0a );
    }
    cache_frame_6178e17e4d40750a1307d73e08fbfc0a = NULL;

    assertFrameObject( frame_6178e17e4d40750a1307d73e08fbfc0a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_8_cubehelix );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_gamma );
    Py_DECREF( par_gamma );
    par_gamma = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    CHECK_OBJECT( (PyObject *)par_r );
    Py_DECREF( par_r );
    par_r = NULL;

    CHECK_OBJECT( (PyObject *)par_h );
    Py_DECREF( par_h );
    par_h = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_gamma );
    Py_DECREF( par_gamma );
    par_gamma = NULL;

    CHECK_OBJECT( (PyObject *)par_s );
    Py_DECREF( par_s );
    par_s = NULL;

    CHECK_OBJECT( (PyObject *)par_r );
    Py_DECREF( par_r );
    par_r = NULL;

    CHECK_OBJECT( (PyObject *)par_h );
    Py_DECREF( par_h );
    par_h = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_8_cubehelix );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_9__g0( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_9__g0 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_9__g0 );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_10__g1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = const_float_0_5;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_10__g1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_10__g1 );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_11__g2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    tmp_return_value = const_int_pos_1;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_11__g2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_11__g2 );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_12__g3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    // Tried code:
    CHECK_OBJECT( par_x );
    tmp_return_value = par_x;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_12__g3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_12__g3 );
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_13__g4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5e8fce4fc39e166a2d0361915147e7ca;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5e8fce4fc39e166a2d0361915147e7ca = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5e8fce4fc39e166a2d0361915147e7ca, codeobj_5e8fce4fc39e166a2d0361915147e7ca, module_matplotlib$_cm, sizeof(void *) );
    frame_5e8fce4fc39e166a2d0361915147e7ca = cache_frame_5e8fce4fc39e166a2d0361915147e7ca;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5e8fce4fc39e166a2d0361915147e7ca );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5e8fce4fc39e166a2d0361915147e7ca ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        tmp_right_name_1 = const_int_pos_2;
        tmp_return_value = POWER_OPERATION( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 118;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e8fce4fc39e166a2d0361915147e7ca );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e8fce4fc39e166a2d0361915147e7ca );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5e8fce4fc39e166a2d0361915147e7ca );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5e8fce4fc39e166a2d0361915147e7ca, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5e8fce4fc39e166a2d0361915147e7ca->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5e8fce4fc39e166a2d0361915147e7ca, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5e8fce4fc39e166a2d0361915147e7ca,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_5e8fce4fc39e166a2d0361915147e7ca == cache_frame_5e8fce4fc39e166a2d0361915147e7ca )
    {
        Py_DECREF( frame_5e8fce4fc39e166a2d0361915147e7ca );
    }
    cache_frame_5e8fce4fc39e166a2d0361915147e7ca = NULL;

    assertFrameObject( frame_5e8fce4fc39e166a2d0361915147e7ca );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_13__g4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_13__g4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_14__g5( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_303af22703fa5d7ab03e56b05a38530a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_303af22703fa5d7ab03e56b05a38530a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_303af22703fa5d7ab03e56b05a38530a, codeobj_303af22703fa5d7ab03e56b05a38530a, module_matplotlib$_cm, sizeof(void *) );
    frame_303af22703fa5d7ab03e56b05a38530a = cache_frame_303af22703fa5d7ab03e56b05a38530a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_303af22703fa5d7ab03e56b05a38530a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_303af22703fa5d7ab03e56b05a38530a ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        tmp_right_name_1 = const_int_pos_3;
        tmp_return_value = POWER_OPERATION( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 119;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_303af22703fa5d7ab03e56b05a38530a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_303af22703fa5d7ab03e56b05a38530a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_303af22703fa5d7ab03e56b05a38530a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_303af22703fa5d7ab03e56b05a38530a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_303af22703fa5d7ab03e56b05a38530a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_303af22703fa5d7ab03e56b05a38530a, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_303af22703fa5d7ab03e56b05a38530a,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_303af22703fa5d7ab03e56b05a38530a == cache_frame_303af22703fa5d7ab03e56b05a38530a )
    {
        Py_DECREF( frame_303af22703fa5d7ab03e56b05a38530a );
    }
    cache_frame_303af22703fa5d7ab03e56b05a38530a = NULL;

    assertFrameObject( frame_303af22703fa5d7ab03e56b05a38530a );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_14__g5 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_14__g5 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_15__g6( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_18b4beebf832bfd38d9855b9aced374d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_18b4beebf832bfd38d9855b9aced374d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_18b4beebf832bfd38d9855b9aced374d, codeobj_18b4beebf832bfd38d9855b9aced374d, module_matplotlib$_cm, sizeof(void *) );
    frame_18b4beebf832bfd38d9855b9aced374d = cache_frame_18b4beebf832bfd38d9855b9aced374d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_18b4beebf832bfd38d9855b9aced374d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_18b4beebf832bfd38d9855b9aced374d ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        tmp_right_name_1 = const_int_pos_4;
        tmp_return_value = POWER_OPERATION( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 120;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18b4beebf832bfd38d9855b9aced374d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_18b4beebf832bfd38d9855b9aced374d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_18b4beebf832bfd38d9855b9aced374d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_18b4beebf832bfd38d9855b9aced374d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_18b4beebf832bfd38d9855b9aced374d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_18b4beebf832bfd38d9855b9aced374d, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_18b4beebf832bfd38d9855b9aced374d,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_18b4beebf832bfd38d9855b9aced374d == cache_frame_18b4beebf832bfd38d9855b9aced374d )
    {
        Py_DECREF( frame_18b4beebf832bfd38d9855b9aced374d );
    }
    cache_frame_18b4beebf832bfd38d9855b9aced374d = NULL;

    assertFrameObject( frame_18b4beebf832bfd38d9855b9aced374d );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_15__g6 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_15__g6 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_16__g7( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3eb187db916caa0fb065588428c318c1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3eb187db916caa0fb065588428c318c1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3eb187db916caa0fb065588428c318c1, codeobj_3eb187db916caa0fb065588428c318c1, module_matplotlib$_cm, sizeof(void *) );
    frame_3eb187db916caa0fb065588428c318c1 = cache_frame_3eb187db916caa0fb065588428c318c1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3eb187db916caa0fb065588428c318c1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3eb187db916caa0fb065588428c318c1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 121;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT( par_x );
        tmp_args_element_name_1 = par_x;
        frame_3eb187db916caa0fb065588428c318c1->m_frame.f_lineno = 121;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sqrt, call_args );
        }

        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 121;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eb187db916caa0fb065588428c318c1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eb187db916caa0fb065588428c318c1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eb187db916caa0fb065588428c318c1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3eb187db916caa0fb065588428c318c1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3eb187db916caa0fb065588428c318c1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3eb187db916caa0fb065588428c318c1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3eb187db916caa0fb065588428c318c1,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_3eb187db916caa0fb065588428c318c1 == cache_frame_3eb187db916caa0fb065588428c318c1 )
    {
        Py_DECREF( frame_3eb187db916caa0fb065588428c318c1 );
    }
    cache_frame_3eb187db916caa0fb065588428c318c1 = NULL;

    assertFrameObject( frame_3eb187db916caa0fb065588428c318c1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_16__g7 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_16__g7 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_17__g8( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3719f9e14b88827afd13fd07c71d8ae1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3719f9e14b88827afd13fd07c71d8ae1 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3719f9e14b88827afd13fd07c71d8ae1, codeobj_3719f9e14b88827afd13fd07c71d8ae1, module_matplotlib$_cm, sizeof(void *) );
    frame_3719f9e14b88827afd13fd07c71d8ae1 = cache_frame_3719f9e14b88827afd13fd07c71d8ae1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3719f9e14b88827afd13fd07c71d8ae1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3719f9e14b88827afd13fd07c71d8ae1 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sqrt );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_2;
        CHECK_OBJECT( par_x );
        tmp_args_element_name_2 = par_x;
        frame_3719f9e14b88827afd13fd07c71d8ae1->m_frame.f_lineno = 122;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_sqrt, call_args );
        }

        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_3719f9e14b88827afd13fd07c71d8ae1->m_frame.f_lineno = 122;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3719f9e14b88827afd13fd07c71d8ae1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3719f9e14b88827afd13fd07c71d8ae1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3719f9e14b88827afd13fd07c71d8ae1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3719f9e14b88827afd13fd07c71d8ae1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3719f9e14b88827afd13fd07c71d8ae1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3719f9e14b88827afd13fd07c71d8ae1, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3719f9e14b88827afd13fd07c71d8ae1,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_3719f9e14b88827afd13fd07c71d8ae1 == cache_frame_3719f9e14b88827afd13fd07c71d8ae1 )
    {
        Py_DECREF( frame_3719f9e14b88827afd13fd07c71d8ae1 );
    }
    cache_frame_3719f9e14b88827afd13fd07c71d8ae1 = NULL;

    assertFrameObject( frame_3719f9e14b88827afd13fd07c71d8ae1 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_17__g8 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_17__g8 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_18__g9( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_1c09eff0e45fde6ecde90c7a9f614ba5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1c09eff0e45fde6ecde90c7a9f614ba5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1c09eff0e45fde6ecde90c7a9f614ba5, codeobj_1c09eff0e45fde6ecde90c7a9f614ba5, module_matplotlib$_cm, sizeof(void *) );
    frame_1c09eff0e45fde6ecde90c7a9f614ba5 = cache_frame_1c09eff0e45fde6ecde90c7a9f614ba5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1c09eff0e45fde6ecde90c7a9f614ba5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1c09eff0e45fde6ecde90c7a9f614ba5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_2;
        tmp_args_element_name_1 = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_1c09eff0e45fde6ecde90c7a9f614ba5->m_frame.f_lineno = 123;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 123;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c09eff0e45fde6ecde90c7a9f614ba5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c09eff0e45fde6ecde90c7a9f614ba5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1c09eff0e45fde6ecde90c7a9f614ba5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1c09eff0e45fde6ecde90c7a9f614ba5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1c09eff0e45fde6ecde90c7a9f614ba5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1c09eff0e45fde6ecde90c7a9f614ba5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1c09eff0e45fde6ecde90c7a9f614ba5,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_1c09eff0e45fde6ecde90c7a9f614ba5 == cache_frame_1c09eff0e45fde6ecde90c7a9f614ba5 )
    {
        Py_DECREF( frame_1c09eff0e45fde6ecde90c7a9f614ba5 );
    }
    cache_frame_1c09eff0e45fde6ecde90c7a9f614ba5 = NULL;

    assertFrameObject( frame_1c09eff0e45fde6ecde90c7a9f614ba5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_18__g9 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_18__g9 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_19__g10( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_55ba6e8ca6ba6f375640e6358def557b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_55ba6e8ca6ba6f375640e6358def557b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_55ba6e8ca6ba6f375640e6358def557b, codeobj_55ba6e8ca6ba6f375640e6358def557b, module_matplotlib$_cm, sizeof(void *) );
    frame_55ba6e8ca6ba6f375640e6358def557b = cache_frame_55ba6e8ca6ba6f375640e6358def557b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_55ba6e8ca6ba6f375640e6358def557b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_55ba6e8ca6ba6f375640e6358def557b ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cos );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_2;
        tmp_args_element_name_1 = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_55ba6e8ca6ba6f375640e6358def557b->m_frame.f_lineno = 124;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 124;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55ba6e8ca6ba6f375640e6358def557b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_55ba6e8ca6ba6f375640e6358def557b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_55ba6e8ca6ba6f375640e6358def557b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_55ba6e8ca6ba6f375640e6358def557b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_55ba6e8ca6ba6f375640e6358def557b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_55ba6e8ca6ba6f375640e6358def557b, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_55ba6e8ca6ba6f375640e6358def557b,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_55ba6e8ca6ba6f375640e6358def557b == cache_frame_55ba6e8ca6ba6f375640e6358def557b )
    {
        Py_DECREF( frame_55ba6e8ca6ba6f375640e6358def557b );
    }
    cache_frame_55ba6e8ca6ba6f375640e6358def557b = NULL;

    assertFrameObject( frame_55ba6e8ca6ba6f375640e6358def557b );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_19__g10 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_19__g10 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_20__g11( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_53cd0df449e64d7ea7808a94a38ef665;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_53cd0df449e64d7ea7808a94a38ef665 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_53cd0df449e64d7ea7808a94a38ef665, codeobj_53cd0df449e64d7ea7808a94a38ef665, module_matplotlib$_cm, sizeof(void *) );
    frame_53cd0df449e64d7ea7808a94a38ef665 = cache_frame_53cd0df449e64d7ea7808a94a38ef665;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_53cd0df449e64d7ea7808a94a38ef665 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_53cd0df449e64d7ea7808a94a38ef665 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 125;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        tmp_right_name_1 = const_float_0_5;
        tmp_args_element_name_1 = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 125;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_53cd0df449e64d7ea7808a94a38ef665->m_frame.f_lineno = 125;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 125;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_53cd0df449e64d7ea7808a94a38ef665 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_53cd0df449e64d7ea7808a94a38ef665 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_53cd0df449e64d7ea7808a94a38ef665 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_53cd0df449e64d7ea7808a94a38ef665, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_53cd0df449e64d7ea7808a94a38ef665->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_53cd0df449e64d7ea7808a94a38ef665, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_53cd0df449e64d7ea7808a94a38ef665,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_53cd0df449e64d7ea7808a94a38ef665 == cache_frame_53cd0df449e64d7ea7808a94a38ef665 )
    {
        Py_DECREF( frame_53cd0df449e64d7ea7808a94a38ef665 );
    }
    cache_frame_53cd0df449e64d7ea7808a94a38ef665 = NULL;

    assertFrameObject( frame_53cd0df449e64d7ea7808a94a38ef665 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_20__g11 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_20__g11 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_21__g12( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_d63c993436bca5f93a9c78ed99803ff4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d63c993436bca5f93a9c78ed99803ff4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d63c993436bca5f93a9c78ed99803ff4, codeobj_d63c993436bca5f93a9c78ed99803ff4, module_matplotlib$_cm, sizeof(void *) );
    frame_d63c993436bca5f93a9c78ed99803ff4 = cache_frame_d63c993436bca5f93a9c78ed99803ff4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d63c993436bca5f93a9c78ed99803ff4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d63c993436bca5f93a9c78ed99803ff4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_left_name_3 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_2 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_3, tmp_right_name_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 126;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_left_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 126;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_2;
        tmp_return_value = POWER_OPERATION( tmp_left_name_1, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 126;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d63c993436bca5f93a9c78ed99803ff4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_d63c993436bca5f93a9c78ed99803ff4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d63c993436bca5f93a9c78ed99803ff4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d63c993436bca5f93a9c78ed99803ff4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d63c993436bca5f93a9c78ed99803ff4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d63c993436bca5f93a9c78ed99803ff4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d63c993436bca5f93a9c78ed99803ff4,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_d63c993436bca5f93a9c78ed99803ff4 == cache_frame_d63c993436bca5f93a9c78ed99803ff4 )
    {
        Py_DECREF( frame_d63c993436bca5f93a9c78ed99803ff4 );
    }
    cache_frame_d63c993436bca5f93a9c78ed99803ff4 = NULL;

    assertFrameObject( frame_d63c993436bca5f93a9c78ed99803ff4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_21__g12 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_21__g12 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_22__g13( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2852c7d737084fabc63ea0ea210f2aa2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2852c7d737084fabc63ea0ea210f2aa2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2852c7d737084fabc63ea0ea210f2aa2, codeobj_2852c7d737084fabc63ea0ea210f2aa2, module_matplotlib$_cm, sizeof(void *) );
    frame_2852c7d737084fabc63ea0ea210f2aa2 = cache_frame_2852c7d737084fabc63ea0ea210f2aa2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2852c7d737084fabc63ea0ea210f2aa2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2852c7d737084fabc63ea0ea210f2aa2 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_2852c7d737084fabc63ea0ea210f2aa2->m_frame.f_lineno = 127;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 127;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2852c7d737084fabc63ea0ea210f2aa2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2852c7d737084fabc63ea0ea210f2aa2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2852c7d737084fabc63ea0ea210f2aa2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2852c7d737084fabc63ea0ea210f2aa2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2852c7d737084fabc63ea0ea210f2aa2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2852c7d737084fabc63ea0ea210f2aa2, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2852c7d737084fabc63ea0ea210f2aa2,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_2852c7d737084fabc63ea0ea210f2aa2 == cache_frame_2852c7d737084fabc63ea0ea210f2aa2 )
    {
        Py_DECREF( frame_2852c7d737084fabc63ea0ea210f2aa2 );
    }
    cache_frame_2852c7d737084fabc63ea0ea210f2aa2 = NULL;

    assertFrameObject( frame_2852c7d737084fabc63ea0ea210f2aa2 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_22__g13 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_22__g13 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_23__g14( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9029bab7a1cf5f66c45b951f2c14fbb5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9029bab7a1cf5f66c45b951f2c14fbb5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9029bab7a1cf5f66c45b951f2c14fbb5, codeobj_9029bab7a1cf5f66c45b951f2c14fbb5, module_matplotlib$_cm, sizeof(void *) );
    frame_9029bab7a1cf5f66c45b951f2c14fbb5 = cache_frame_9029bab7a1cf5f66c45b951f2c14fbb5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9029bab7a1cf5f66c45b951f2c14fbb5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9029bab7a1cf5f66c45b951f2c14fbb5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_cos );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_1 = par_x;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_pi );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_9029bab7a1cf5f66c45b951f2c14fbb5->m_frame.f_lineno = 128;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_9029bab7a1cf5f66c45b951f2c14fbb5->m_frame.f_lineno = 128;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 128;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9029bab7a1cf5f66c45b951f2c14fbb5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9029bab7a1cf5f66c45b951f2c14fbb5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9029bab7a1cf5f66c45b951f2c14fbb5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9029bab7a1cf5f66c45b951f2c14fbb5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9029bab7a1cf5f66c45b951f2c14fbb5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9029bab7a1cf5f66c45b951f2c14fbb5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9029bab7a1cf5f66c45b951f2c14fbb5,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_9029bab7a1cf5f66c45b951f2c14fbb5 == cache_frame_9029bab7a1cf5f66c45b951f2c14fbb5 )
    {
        Py_DECREF( frame_9029bab7a1cf5f66c45b951f2c14fbb5 );
    }
    cache_frame_9029bab7a1cf5f66c45b951f2c14fbb5 = NULL;

    assertFrameObject( frame_9029bab7a1cf5f66c45b951f2c14fbb5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_23__g14 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_23__g14 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_24__g15( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_27e2261ab6c9abc0e016656ef2877a5e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_27e2261ab6c9abc0e016656ef2877a5e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_27e2261ab6c9abc0e016656ef2877a5e, codeobj_27e2261ab6c9abc0e016656ef2877a5e, module_matplotlib$_cm, sizeof(void *) );
    frame_27e2261ab6c9abc0e016656ef2877a5e = cache_frame_27e2261ab6c9abc0e016656ef2877a5e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27e2261ab6c9abc0e016656ef2877a5e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27e2261ab6c9abc0e016656ef2877a5e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_sin );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_int_pos_2;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_LONG( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_27e2261ab6c9abc0e016656ef2877a5e->m_frame.f_lineno = 129;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 129;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27e2261ab6c9abc0e016656ef2877a5e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_27e2261ab6c9abc0e016656ef2877a5e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27e2261ab6c9abc0e016656ef2877a5e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27e2261ab6c9abc0e016656ef2877a5e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27e2261ab6c9abc0e016656ef2877a5e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27e2261ab6c9abc0e016656ef2877a5e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_27e2261ab6c9abc0e016656ef2877a5e,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_27e2261ab6c9abc0e016656ef2877a5e == cache_frame_27e2261ab6c9abc0e016656ef2877a5e )
    {
        Py_DECREF( frame_27e2261ab6c9abc0e016656ef2877a5e );
    }
    cache_frame_27e2261ab6c9abc0e016656ef2877a5e = NULL;

    assertFrameObject( frame_27e2261ab6c9abc0e016656ef2877a5e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_24__g15 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_24__g15 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_25__g16( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3eeb63045fca5a861f2fe37fdedc6787;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3eeb63045fca5a861f2fe37fdedc6787 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3eeb63045fca5a861f2fe37fdedc6787, codeobj_3eeb63045fca5a861f2fe37fdedc6787, module_matplotlib$_cm, sizeof(void *) );
    frame_3eeb63045fca5a861f2fe37fdedc6787 = cache_frame_3eeb63045fca5a861f2fe37fdedc6787;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3eeb63045fca5a861f2fe37fdedc6787 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3eeb63045fca5a861f2fe37fdedc6787 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cos );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_int_pos_2;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_LONG( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_3eeb63045fca5a861f2fe37fdedc6787->m_frame.f_lineno = 130;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 130;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eeb63045fca5a861f2fe37fdedc6787 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eeb63045fca5a861f2fe37fdedc6787 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3eeb63045fca5a861f2fe37fdedc6787 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3eeb63045fca5a861f2fe37fdedc6787, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3eeb63045fca5a861f2fe37fdedc6787->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3eeb63045fca5a861f2fe37fdedc6787, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3eeb63045fca5a861f2fe37fdedc6787,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_3eeb63045fca5a861f2fe37fdedc6787 == cache_frame_3eeb63045fca5a861f2fe37fdedc6787 )
    {
        Py_DECREF( frame_3eeb63045fca5a861f2fe37fdedc6787 );
    }
    cache_frame_3eeb63045fca5a861f2fe37fdedc6787 = NULL;

    assertFrameObject( frame_3eeb63045fca5a861f2fe37fdedc6787 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_25__g16 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_25__g16 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_26__g17( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_e119297376def3fb48f19b5a35d19efc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e119297376def3fb48f19b5a35d19efc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e119297376def3fb48f19b5a35d19efc, codeobj_e119297376def3fb48f19b5a35d19efc, module_matplotlib$_cm, sizeof(void *) );
    frame_e119297376def3fb48f19b5a35d19efc = cache_frame_e119297376def3fb48f19b5a35d19efc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e119297376def3fb48f19b5a35d19efc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e119297376def3fb48f19b5a35d19efc ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_sin );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_int_pos_2;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_LONG( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e119297376def3fb48f19b5a35d19efc->m_frame.f_lineno = 131;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e119297376def3fb48f19b5a35d19efc->m_frame.f_lineno = 131;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 131;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e119297376def3fb48f19b5a35d19efc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e119297376def3fb48f19b5a35d19efc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e119297376def3fb48f19b5a35d19efc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e119297376def3fb48f19b5a35d19efc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e119297376def3fb48f19b5a35d19efc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e119297376def3fb48f19b5a35d19efc, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e119297376def3fb48f19b5a35d19efc,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_e119297376def3fb48f19b5a35d19efc == cache_frame_e119297376def3fb48f19b5a35d19efc )
    {
        Py_DECREF( frame_e119297376def3fb48f19b5a35d19efc );
    }
    cache_frame_e119297376def3fb48f19b5a35d19efc = NULL;

    assertFrameObject( frame_e119297376def3fb48f19b5a35d19efc );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_26__g17 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_26__g17 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_27__g18( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_4073d3ca4fbe497a448f547e8ecc72d7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4073d3ca4fbe497a448f547e8ecc72d7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4073d3ca4fbe497a448f547e8ecc72d7, codeobj_4073d3ca4fbe497a448f547e8ecc72d7, module_matplotlib$_cm, sizeof(void *) );
    frame_4073d3ca4fbe497a448f547e8ecc72d7 = cache_frame_4073d3ca4fbe497a448f547e8ecc72d7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4073d3ca4fbe497a448f547e8ecc72d7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4073d3ca4fbe497a448f547e8ecc72d7 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_cos );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_int_pos_2;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_LONG( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_4073d3ca4fbe497a448f547e8ecc72d7->m_frame.f_lineno = 132;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_4073d3ca4fbe497a448f547e8ecc72d7->m_frame.f_lineno = 132;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 132;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4073d3ca4fbe497a448f547e8ecc72d7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4073d3ca4fbe497a448f547e8ecc72d7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4073d3ca4fbe497a448f547e8ecc72d7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4073d3ca4fbe497a448f547e8ecc72d7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4073d3ca4fbe497a448f547e8ecc72d7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4073d3ca4fbe497a448f547e8ecc72d7, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4073d3ca4fbe497a448f547e8ecc72d7,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_4073d3ca4fbe497a448f547e8ecc72d7 == cache_frame_4073d3ca4fbe497a448f547e8ecc72d7 )
    {
        Py_DECREF( frame_4073d3ca4fbe497a448f547e8ecc72d7 );
    }
    cache_frame_4073d3ca4fbe497a448f547e8ecc72d7 = NULL;

    assertFrameObject( frame_4073d3ca4fbe497a448f547e8ecc72d7 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_27__g18 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_27__g18 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_28__g19( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_8a3cccd29b4301344b470b317d475974;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8a3cccd29b4301344b470b317d475974 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8a3cccd29b4301344b470b317d475974, codeobj_8a3cccd29b4301344b470b317d475974, module_matplotlib$_cm, sizeof(void *) );
    frame_8a3cccd29b4301344b470b317d475974 = cache_frame_8a3cccd29b4301344b470b317d475974;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8a3cccd29b4301344b470b317d475974 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8a3cccd29b4301344b470b317d475974 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_sin );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_int_pos_4;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_LONG( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8a3cccd29b4301344b470b317d475974->m_frame.f_lineno = 133;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_8a3cccd29b4301344b470b317d475974->m_frame.f_lineno = 133;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 133;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a3cccd29b4301344b470b317d475974 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a3cccd29b4301344b470b317d475974 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8a3cccd29b4301344b470b317d475974 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8a3cccd29b4301344b470b317d475974, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8a3cccd29b4301344b470b317d475974->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8a3cccd29b4301344b470b317d475974, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8a3cccd29b4301344b470b317d475974,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_8a3cccd29b4301344b470b317d475974 == cache_frame_8a3cccd29b4301344b470b317d475974 )
    {
        Py_DECREF( frame_8a3cccd29b4301344b470b317d475974 );
    }
    cache_frame_8a3cccd29b4301344b470b317d475974 = NULL;

    assertFrameObject( frame_8a3cccd29b4301344b470b317d475974 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_28__g19 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_28__g19 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_29__g20( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_b5d521e44c58af8e9d25ee8f3491d39e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b5d521e44c58af8e9d25ee8f3491d39e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b5d521e44c58af8e9d25ee8f3491d39e, codeobj_b5d521e44c58af8e9d25ee8f3491d39e, module_matplotlib$_cm, sizeof(void *) );
    frame_b5d521e44c58af8e9d25ee8f3491d39e = cache_frame_b5d521e44c58af8e9d25ee8f3491d39e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b5d521e44c58af8e9d25ee8f3491d39e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b5d521e44c58af8e9d25ee8f3491d39e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_source_name_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_source_name_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_2 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_2 = tmp_mvar_value_2;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_cos );
        if ( tmp_called_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_int_pos_4;
        tmp_left_name_1 = BINARY_OPERATION_MUL_OBJECT_LONG( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_3 == NULL )
        {
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_3 = tmp_mvar_value_3;
        tmp_right_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_pi );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );
            Py_DECREF( tmp_left_name_1 );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = BINARY_OPERATION_MUL_OBJECT_OBJECT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_args_element_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );
            Py_DECREF( tmp_called_name_2 );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_b5d521e44c58af8e9d25ee8f3491d39e->m_frame.f_lineno = 134;
        {
            PyObject *call_args[] = { tmp_args_element_name_2 };
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
        }

        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_b5d521e44c58af8e9d25ee8f3491d39e->m_frame.f_lineno = 134;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 134;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b5d521e44c58af8e9d25ee8f3491d39e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b5d521e44c58af8e9d25ee8f3491d39e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b5d521e44c58af8e9d25ee8f3491d39e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b5d521e44c58af8e9d25ee8f3491d39e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b5d521e44c58af8e9d25ee8f3491d39e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b5d521e44c58af8e9d25ee8f3491d39e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b5d521e44c58af8e9d25ee8f3491d39e,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_b5d521e44c58af8e9d25ee8f3491d39e == cache_frame_b5d521e44c58af8e9d25ee8f3491d39e )
    {
        Py_DECREF( frame_b5d521e44c58af8e9d25ee8f3491d39e );
    }
    cache_frame_b5d521e44c58af8e9d25ee8f3491d39e = NULL;

    assertFrameObject( frame_b5d521e44c58af8e9d25ee8f3491d39e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_29__g20 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_29__g20 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_30__g21( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3f141603091f9e79166fc67462636516;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3f141603091f9e79166fc67462636516 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3f141603091f9e79166fc67462636516, codeobj_3f141603091f9e79166fc67462636516, module_matplotlib$_cm, sizeof(void *) );
    frame_3f141603091f9e79166fc67462636516 = cache_frame_3f141603091f9e79166fc67462636516;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3f141603091f9e79166fc67462636516 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3f141603091f9e79166fc67462636516 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_return_value = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 135;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f141603091f9e79166fc67462636516 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f141603091f9e79166fc67462636516 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3f141603091f9e79166fc67462636516 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3f141603091f9e79166fc67462636516, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3f141603091f9e79166fc67462636516->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3f141603091f9e79166fc67462636516, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f141603091f9e79166fc67462636516,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_3f141603091f9e79166fc67462636516 == cache_frame_3f141603091f9e79166fc67462636516 )
    {
        Py_DECREF( frame_3f141603091f9e79166fc67462636516 );
    }
    cache_frame_3f141603091f9e79166fc67462636516 = NULL;

    assertFrameObject( frame_3f141603091f9e79166fc67462636516 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_30__g21 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_30__g21 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_31__g22( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_71be7a18f282021ca0991601b42aca58;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_71be7a18f282021ca0991601b42aca58 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_71be7a18f282021ca0991601b42aca58, codeobj_71be7a18f282021ca0991601b42aca58, module_matplotlib$_cm, sizeof(void *) );
    frame_71be7a18f282021ca0991601b42aca58 = cache_frame_71be7a18f282021ca0991601b42aca58;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_71be7a18f282021ca0991601b42aca58 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_71be7a18f282021ca0991601b42aca58 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 136;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_71be7a18f282021ca0991601b42aca58 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_71be7a18f282021ca0991601b42aca58 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_71be7a18f282021ca0991601b42aca58 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_71be7a18f282021ca0991601b42aca58, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_71be7a18f282021ca0991601b42aca58->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_71be7a18f282021ca0991601b42aca58, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_71be7a18f282021ca0991601b42aca58,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_71be7a18f282021ca0991601b42aca58 == cache_frame_71be7a18f282021ca0991601b42aca58 )
    {
        Py_DECREF( frame_71be7a18f282021ca0991601b42aca58 );
    }
    cache_frame_71be7a18f282021ca0991601b42aca58 = NULL;

    assertFrameObject( frame_71be7a18f282021ca0991601b42aca58 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_31__g22 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_31__g22 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_32__g23( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_24fee38c9e266482a2e45eea3fe5f704;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_24fee38c9e266482a2e45eea3fe5f704 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_24fee38c9e266482a2e45eea3fe5f704, codeobj_24fee38c9e266482a2e45eea3fe5f704, module_matplotlib$_cm, sizeof(void *) );
    frame_24fee38c9e266482a2e45eea3fe5f704 = cache_frame_24fee38c9e266482a2e45eea3fe5f704;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_24fee38c9e266482a2e45eea3fe5f704 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_24fee38c9e266482a2e45eea3fe5f704 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 137;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_2;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 137;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24fee38c9e266482a2e45eea3fe5f704 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_24fee38c9e266482a2e45eea3fe5f704 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24fee38c9e266482a2e45eea3fe5f704 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_24fee38c9e266482a2e45eea3fe5f704, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_24fee38c9e266482a2e45eea3fe5f704->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_24fee38c9e266482a2e45eea3fe5f704, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24fee38c9e266482a2e45eea3fe5f704,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_24fee38c9e266482a2e45eea3fe5f704 == cache_frame_24fee38c9e266482a2e45eea3fe5f704 )
    {
        Py_DECREF( frame_24fee38c9e266482a2e45eea3fe5f704 );
    }
    cache_frame_24fee38c9e266482a2e45eea3fe5f704 = NULL;

    assertFrameObject( frame_24fee38c9e266482a2e45eea3fe5f704 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_32__g23 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_32__g23 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_33__g24( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_93f63737e8d01a5e712320109901c660;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_93f63737e8d01a5e712320109901c660 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_93f63737e8d01a5e712320109901c660, codeobj_93f63737e8d01a5e712320109901c660, module_matplotlib$_cm, sizeof(void *) );
    frame_93f63737e8d01a5e712320109901c660 = cache_frame_93f63737e8d01a5e712320109901c660;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_93f63737e8d01a5e712320109901c660 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_93f63737e8d01a5e712320109901c660 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_args_element_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_93f63737e8d01a5e712320109901c660->m_frame.f_lineno = 138;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 138;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93f63737e8d01a5e712320109901c660 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_93f63737e8d01a5e712320109901c660 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_93f63737e8d01a5e712320109901c660 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_93f63737e8d01a5e712320109901c660, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_93f63737e8d01a5e712320109901c660->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_93f63737e8d01a5e712320109901c660, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_93f63737e8d01a5e712320109901c660,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_93f63737e8d01a5e712320109901c660 == cache_frame_93f63737e8d01a5e712320109901c660 )
    {
        Py_DECREF( frame_93f63737e8d01a5e712320109901c660 );
    }
    cache_frame_93f63737e8d01a5e712320109901c660 = NULL;

    assertFrameObject( frame_93f63737e8d01a5e712320109901c660 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_33__g24 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_33__g24 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_34__g25( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_9a049aa6ab7d4ac8f3db952c101016b3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9a049aa6ab7d4ac8f3db952c101016b3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9a049aa6ab7d4ac8f3db952c101016b3, codeobj_9a049aa6ab7d4ac8f3db952c101016b3, module_matplotlib$_cm, sizeof(void *) );
    frame_9a049aa6ab7d4ac8f3db952c101016b3 = cache_frame_9a049aa6ab7d4ac8f3db952c101016b3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9a049aa6ab7d4ac8f3db952c101016b3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9a049aa6ab7d4ac8f3db952c101016b3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_2;
        tmp_args_element_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_9a049aa6ab7d4ac8f3db952c101016b3->m_frame.f_lineno = 139;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 139;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9a049aa6ab7d4ac8f3db952c101016b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_9a049aa6ab7d4ac8f3db952c101016b3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9a049aa6ab7d4ac8f3db952c101016b3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9a049aa6ab7d4ac8f3db952c101016b3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9a049aa6ab7d4ac8f3db952c101016b3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9a049aa6ab7d4ac8f3db952c101016b3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9a049aa6ab7d4ac8f3db952c101016b3,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_9a049aa6ab7d4ac8f3db952c101016b3 == cache_frame_9a049aa6ab7d4ac8f3db952c101016b3 )
    {
        Py_DECREF( frame_9a049aa6ab7d4ac8f3db952c101016b3 );
    }
    cache_frame_9a049aa6ab7d4ac8f3db952c101016b3 = NULL;

    assertFrameObject( frame_9a049aa6ab7d4ac8f3db952c101016b3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_34__g25 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_34__g25 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_35__g26( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_59430b3c1d9efa7f67144ba688bce895;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_59430b3c1d9efa7f67144ba688bce895 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_59430b3c1d9efa7f67144ba688bce895, codeobj_59430b3c1d9efa7f67144ba688bce895, module_matplotlib$_cm, sizeof(void *) );
    frame_59430b3c1d9efa7f67144ba688bce895 = cache_frame_59430b3c1d9efa7f67144ba688bce895;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_59430b3c1d9efa7f67144ba688bce895 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_59430b3c1d9efa7f67144ba688bce895 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_left_name_3 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_2 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_3, tmp_right_name_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 140;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_left_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 140;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_2;
        tmp_return_value = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_1, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 140;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59430b3c1d9efa7f67144ba688bce895 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_59430b3c1d9efa7f67144ba688bce895 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_59430b3c1d9efa7f67144ba688bce895 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_59430b3c1d9efa7f67144ba688bce895, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_59430b3c1d9efa7f67144ba688bce895->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_59430b3c1d9efa7f67144ba688bce895, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_59430b3c1d9efa7f67144ba688bce895,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_59430b3c1d9efa7f67144ba688bce895 == cache_frame_59430b3c1d9efa7f67144ba688bce895 )
    {
        Py_DECREF( frame_59430b3c1d9efa7f67144ba688bce895 );
    }
    cache_frame_59430b3c1d9efa7f67144ba688bce895 = NULL;

    assertFrameObject( frame_59430b3c1d9efa7f67144ba688bce895 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_35__g26 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_35__g26 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_36__g27( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_2e9d0097cf3c6357824a05b9a838d1ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2e9d0097cf3c6357824a05b9a838d1ef = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2e9d0097cf3c6357824a05b9a838d1ef, codeobj_2e9d0097cf3c6357824a05b9a838d1ef, module_matplotlib$_cm, sizeof(void *) );
    frame_2e9d0097cf3c6357824a05b9a838d1ef = cache_frame_2e9d0097cf3c6357824a05b9a838d1ef;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2e9d0097cf3c6357824a05b9a838d1ef );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2e9d0097cf3c6357824a05b9a838d1ef ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_left_name_3 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_2 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_3, tmp_right_name_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_2;
        tmp_left_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_2;
        tmp_return_value = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_1, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 141;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2e9d0097cf3c6357824a05b9a838d1ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_2e9d0097cf3c6357824a05b9a838d1ef );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2e9d0097cf3c6357824a05b9a838d1ef );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2e9d0097cf3c6357824a05b9a838d1ef, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2e9d0097cf3c6357824a05b9a838d1ef->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2e9d0097cf3c6357824a05b9a838d1ef, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2e9d0097cf3c6357824a05b9a838d1ef,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_2e9d0097cf3c6357824a05b9a838d1ef == cache_frame_2e9d0097cf3c6357824a05b9a838d1ef )
    {
        Py_DECREF( frame_2e9d0097cf3c6357824a05b9a838d1ef );
    }
    cache_frame_2e9d0097cf3c6357824a05b9a838d1ef = NULL;

    assertFrameObject( frame_2e9d0097cf3c6357824a05b9a838d1ef );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_36__g27 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_36__g27 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_37__g28( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_560516ef25ad4926357a26fe2e0ee1fe;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_560516ef25ad4926357a26fe2e0ee1fe = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_560516ef25ad4926357a26fe2e0ee1fe, codeobj_560516ef25ad4926357a26fe2e0ee1fe, module_matplotlib$_cm, sizeof(void *) );
    frame_560516ef25ad4926357a26fe2e0ee1fe = cache_frame_560516ef25ad4926357a26fe2e0ee1fe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_560516ef25ad4926357a26fe2e0ee1fe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_560516ef25ad4926357a26fe2e0ee1fe ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 142;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 142;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_3 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_2 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_3, tmp_right_name_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 142;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_left_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 142;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_2;
        tmp_args_element_name_1 = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_1, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 142;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_560516ef25ad4926357a26fe2e0ee1fe->m_frame.f_lineno = 142;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 142;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_560516ef25ad4926357a26fe2e0ee1fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_560516ef25ad4926357a26fe2e0ee1fe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_560516ef25ad4926357a26fe2e0ee1fe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_560516ef25ad4926357a26fe2e0ee1fe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_560516ef25ad4926357a26fe2e0ee1fe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_560516ef25ad4926357a26fe2e0ee1fe, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_560516ef25ad4926357a26fe2e0ee1fe,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_560516ef25ad4926357a26fe2e0ee1fe == cache_frame_560516ef25ad4926357a26fe2e0ee1fe )
    {
        Py_DECREF( frame_560516ef25ad4926357a26fe2e0ee1fe );
    }
    cache_frame_560516ef25ad4926357a26fe2e0ee1fe = NULL;

    assertFrameObject( frame_560516ef25ad4926357a26fe2e0ee1fe );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_37__g28 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_37__g28 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_38__g29( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_dab820f0e92ed8284b12269dc4bb5313;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_dab820f0e92ed8284b12269dc4bb5313 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dab820f0e92ed8284b12269dc4bb5313, codeobj_dab820f0e92ed8284b12269dc4bb5313, module_matplotlib$_cm, sizeof(void *) );
    frame_dab820f0e92ed8284b12269dc4bb5313 = cache_frame_dab820f0e92ed8284b12269dc4bb5313;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dab820f0e92ed8284b12269dc4bb5313 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dab820f0e92ed8284b12269dc4bb5313 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 143;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 143;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_3 = const_int_pos_3;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_2 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_3, tmp_right_name_1 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 143;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_2;
        tmp_left_name_1 = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 143;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_3 = const_int_pos_2;
        tmp_args_element_name_1 = BINARY_OPERATION_TRUEDIV_OBJECT_LONG( tmp_left_name_1, tmp_right_name_3 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 143;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_dab820f0e92ed8284b12269dc4bb5313->m_frame.f_lineno = 143;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 143;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dab820f0e92ed8284b12269dc4bb5313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_dab820f0e92ed8284b12269dc4bb5313 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dab820f0e92ed8284b12269dc4bb5313 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dab820f0e92ed8284b12269dc4bb5313, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dab820f0e92ed8284b12269dc4bb5313->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dab820f0e92ed8284b12269dc4bb5313, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_dab820f0e92ed8284b12269dc4bb5313,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_dab820f0e92ed8284b12269dc4bb5313 == cache_frame_dab820f0e92ed8284b12269dc4bb5313 )
    {
        Py_DECREF( frame_dab820f0e92ed8284b12269dc4bb5313 );
    }
    cache_frame_dab820f0e92ed8284b12269dc4bb5313 = NULL;

    assertFrameObject( frame_dab820f0e92ed8284b12269dc4bb5313 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_38__g29 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_38__g29 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_39__g30( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_6eba6b875aee118971f5958bd375cae4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6eba6b875aee118971f5958bd375cae4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6eba6b875aee118971f5958bd375cae4, codeobj_6eba6b875aee118971f5958bd375cae4, module_matplotlib$_cm, sizeof(void *) );
    frame_6eba6b875aee118971f5958bd375cae4 = cache_frame_6eba6b875aee118971f5958bd375cae4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6eba6b875aee118971f5958bd375cae4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6eba6b875aee118971f5958bd375cae4 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT( par_x );
        tmp_left_name_2 = par_x;
        tmp_right_name_1 = const_float_0_32;
        tmp_left_name_1 = BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 144;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_float_0_78125;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 144;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6eba6b875aee118971f5958bd375cae4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6eba6b875aee118971f5958bd375cae4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6eba6b875aee118971f5958bd375cae4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6eba6b875aee118971f5958bd375cae4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6eba6b875aee118971f5958bd375cae4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6eba6b875aee118971f5958bd375cae4, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6eba6b875aee118971f5958bd375cae4,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_6eba6b875aee118971f5958bd375cae4 == cache_frame_6eba6b875aee118971f5958bd375cae4 )
    {
        Py_DECREF( frame_6eba6b875aee118971f5958bd375cae4 );
    }
    cache_frame_6eba6b875aee118971f5958bd375cae4 = NULL;

    assertFrameObject( frame_6eba6b875aee118971f5958bd375cae4 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_39__g30 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_39__g30 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_40__g31( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_56c9d341f43b8152629e1d5e5810ecb3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_56c9d341f43b8152629e1d5e5810ecb3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_56c9d341f43b8152629e1d5e5810ecb3, codeobj_56c9d341f43b8152629e1d5e5810ecb3, module_matplotlib$_cm, sizeof(void *) );
    frame_56c9d341f43b8152629e1d5e5810ecb3 = cache_frame_56c9d341f43b8152629e1d5e5810ecb3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_56c9d341f43b8152629e1d5e5810ecb3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_56c9d341f43b8152629e1d5e5810ecb3 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 145;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_float_0_84;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 145;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56c9d341f43b8152629e1d5e5810ecb3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_56c9d341f43b8152629e1d5e5810ecb3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56c9d341f43b8152629e1d5e5810ecb3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_56c9d341f43b8152629e1d5e5810ecb3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_56c9d341f43b8152629e1d5e5810ecb3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_56c9d341f43b8152629e1d5e5810ecb3, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_56c9d341f43b8152629e1d5e5810ecb3,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_56c9d341f43b8152629e1d5e5810ecb3 == cache_frame_56c9d341f43b8152629e1d5e5810ecb3 )
    {
        Py_DECREF( frame_56c9d341f43b8152629e1d5e5810ecb3 );
    }
    cache_frame_56c9d341f43b8152629e1d5e5810ecb3 = NULL;

    assertFrameObject( frame_56c9d341f43b8152629e1d5e5810ecb3 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_40__g31 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_40__g31 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_41__g32( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    PyObject *var_ret = NULL;
    PyObject *var_m = NULL;
    struct Nuitka_FrameObject *frame_1d722020af9b4fc79a1556ef37f5760e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_1d722020af9b4fc79a1556ef37f5760e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1d722020af9b4fc79a1556ef37f5760e, codeobj_1d722020af9b4fc79a1556ef37f5760e, module_matplotlib$_cm, sizeof(void *)+sizeof(void *)+sizeof(void *) );
    frame_1d722020af9b4fc79a1556ef37f5760e = cache_frame_1d722020af9b4fc79a1556ef37f5760e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1d722020af9b4fc79a1556ef37f5760e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1d722020af9b4fc79a1556ef37f5760e ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_len_arg_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 147;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_zeros );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 147;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_len_arg_1 = par_x;
        tmp_args_element_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 147;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_1d722020af9b4fc79a1556ef37f5760e->m_frame.f_lineno = 147;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_assign_source_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 147;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_ret == NULL );
        var_ret = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT( par_x );
        tmp_compexpr_left_1 = par_x;
        tmp_compexpr_right_1 = const_float_0_25;
        tmp_assign_source_2 = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
        if ( tmp_assign_source_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 148;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert( var_m == NULL );
        var_m = tmp_assign_source_2;
    }
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        tmp_left_name_1 = const_int_pos_4;
        CHECK_OBJECT( par_x );
        tmp_subscribed_name_1 = par_x;
        CHECK_OBJECT( var_m );
        tmp_subscript_name_1 = var_m;
        tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
        if ( tmp_right_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_ass_subvalue_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        Py_DECREF( tmp_right_name_1 );
        if ( tmp_ass_subvalue_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ret );
        tmp_ass_subscribed_1 = var_ret;
        CHECK_OBJECT( var_m );
        tmp_ass_subscript_1 = var_m;
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
        Py_DECREF( tmp_ass_subvalue_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 149;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_left_name_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        CHECK_OBJECT( par_x );
        tmp_compexpr_left_2 = par_x;
        tmp_compexpr_right_2 = const_float_0_25;
        tmp_left_name_2 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
        if ( tmp_left_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 150;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( par_x );
        tmp_compexpr_left_3 = par_x;
        tmp_compexpr_right_3 = const_float_0_92;
        tmp_right_name_2 = RICH_COMPARE_LT_OBJECT_OBJECT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
        if ( tmp_right_name_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_left_name_2 );

            exception_lineno = 150;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = BINARY_OPERATION( PyNumber_And, tmp_left_name_2, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_2 );
        Py_DECREF( tmp_right_name_2 );
        if ( tmp_assign_source_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 150;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_m;
            assert( old != NULL );
            var_m = tmp_assign_source_3;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_3;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_right_name_4;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        tmp_left_name_4 = const_int_neg_2;
        CHECK_OBJECT( par_x );
        tmp_subscribed_name_2 = par_x;
        CHECK_OBJECT( var_m );
        tmp_subscript_name_2 = var_m;
        tmp_right_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
        if ( tmp_right_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 151;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_3 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_4, tmp_right_name_3 );
        Py_DECREF( tmp_right_name_3 );
        if ( tmp_left_name_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 151;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_4 = const_float_1_84;
        tmp_ass_subvalue_2 = BINARY_OPERATION_ADD_OBJECT_FLOAT( tmp_left_name_3, tmp_right_name_4 );
        Py_DECREF( tmp_left_name_3 );
        if ( tmp_ass_subvalue_2 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 151;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ret );
        tmp_ass_subscribed_2 = var_ret;
        CHECK_OBJECT( var_m );
        tmp_ass_subscript_2 = var_m;
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2 );
        Py_DECREF( tmp_ass_subvalue_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 151;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT( par_x );
        tmp_compexpr_left_4 = par_x;
        tmp_compexpr_right_4 = const_float_0_92;
        tmp_assign_source_4 = RICH_COMPARE_GTE_OBJECT_OBJECT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 152;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_m;
            assert( old != NULL );
            var_m = tmp_assign_source_4;
            Py_DECREF( old );
        }

    }
    {
        PyObject *tmp_ass_subvalue_3;
        PyObject *tmp_left_name_5;
        PyObject *tmp_left_name_6;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_right_name_5;
        PyObject *tmp_right_name_6;
        PyObject *tmp_ass_subscribed_3;
        PyObject *tmp_ass_subscript_3;
        CHECK_OBJECT( par_x );
        tmp_subscribed_name_3 = par_x;
        CHECK_OBJECT( var_m );
        tmp_subscript_name_3 = var_m;
        tmp_left_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
        if ( tmp_left_name_6 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_5 = const_float_0_08;
        tmp_left_name_5 = BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT( tmp_left_name_6, tmp_right_name_5 );
        Py_DECREF( tmp_left_name_6 );
        if ( tmp_left_name_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_6 = const_float_11_5;
        tmp_ass_subvalue_3 = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_5, tmp_right_name_6 );
        Py_DECREF( tmp_left_name_5 );
        if ( tmp_ass_subvalue_3 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT( var_ret );
        tmp_ass_subscribed_3 = var_ret;
        CHECK_OBJECT( var_m );
        tmp_ass_subscript_3 = var_m;
        tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_3, tmp_ass_subscript_3, tmp_ass_subvalue_3 );
        Py_DECREF( tmp_ass_subvalue_3 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 153;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d722020af9b4fc79a1556ef37f5760e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1d722020af9b4fc79a1556ef37f5760e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1d722020af9b4fc79a1556ef37f5760e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1d722020af9b4fc79a1556ef37f5760e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1d722020af9b4fc79a1556ef37f5760e, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1d722020af9b4fc79a1556ef37f5760e,
        type_description_1,
        par_x,
        var_ret,
        var_m
    );


    // Release cached frame.
    if ( frame_1d722020af9b4fc79a1556ef37f5760e == cache_frame_1d722020af9b4fc79a1556ef37f5760e )
    {
        Py_DECREF( frame_1d722020af9b4fc79a1556ef37f5760e );
    }
    cache_frame_1d722020af9b4fc79a1556ef37f5760e = NULL;

    assertFrameObject( frame_1d722020af9b4fc79a1556ef37f5760e );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT( var_ret );
    tmp_return_value = var_ret;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_41__g32 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    CHECK_OBJECT( (PyObject *)var_m );
    Py_DECREF( var_m );
    var_m = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    Py_XDECREF( var_m );
    var_m = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_41__g32 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_42__g33( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_274d1243a2ef895f960c92b92c710875;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_274d1243a2ef895f960c92b92c710875 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_274d1243a2ef895f960c92b92c710875, codeobj_274d1243a2ef895f960c92b92c710875, module_matplotlib$_cm, sizeof(void *) );
    frame_274d1243a2ef895f960c92b92c710875 = cache_frame_274d1243a2ef895f960c92b92c710875;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_274d1243a2ef895f960c92b92c710875 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_274d1243a2ef895f960c92b92c710875 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_np );
        }

        if ( tmp_mvar_value_1 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "np" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 155;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_source_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_abs );
        if ( tmp_called_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 155;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 155;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_float_0_5;
        tmp_args_element_name_1 = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_args_element_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_called_name_1 );

            exception_lineno = 155;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_274d1243a2ef895f960c92b92c710875->m_frame.f_lineno = 155;
        {
            PyObject *call_args[] = { tmp_args_element_name_1 };
            tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
        }

        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 155;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_274d1243a2ef895f960c92b92c710875 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_274d1243a2ef895f960c92b92c710875 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_274d1243a2ef895f960c92b92c710875 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_274d1243a2ef895f960c92b92c710875, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_274d1243a2ef895f960c92b92c710875->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_274d1243a2ef895f960c92b92c710875, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_274d1243a2ef895f960c92b92c710875,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_274d1243a2ef895f960c92b92c710875 == cache_frame_274d1243a2ef895f960c92b92c710875 )
    {
        Py_DECREF( frame_274d1243a2ef895f960c92b92c710875 );
    }
    cache_frame_274d1243a2ef895f960c92b92c710875 = NULL;

    assertFrameObject( frame_274d1243a2ef895f960c92b92c710875 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_42__g33 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_42__g33 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_43__g34( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_a8a16c55fe462d4caf5ee4e050c4e1bf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a8a16c55fe462d4caf5ee4e050c4e1bf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a8a16c55fe462d4caf5ee4e050c4e1bf, codeobj_a8a16c55fe462d4caf5ee4e050c4e1bf, module_matplotlib$_cm, sizeof(void *) );
    frame_a8a16c55fe462d4caf5ee4e050c4e1bf = cache_frame_a8a16c55fe462d4caf5ee4e050c4e1bf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a8a16c55fe462d4caf5ee4e050c4e1bf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a8a16c55fe462d4caf5ee4e050c4e1bf ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_return_value = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 156;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8a16c55fe462d4caf5ee4e050c4e1bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8a16c55fe462d4caf5ee4e050c4e1bf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a8a16c55fe462d4caf5ee4e050c4e1bf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a8a16c55fe462d4caf5ee4e050c4e1bf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a8a16c55fe462d4caf5ee4e050c4e1bf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a8a16c55fe462d4caf5ee4e050c4e1bf, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a8a16c55fe462d4caf5ee4e050c4e1bf,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_a8a16c55fe462d4caf5ee4e050c4e1bf == cache_frame_a8a16c55fe462d4caf5ee4e050c4e1bf )
    {
        Py_DECREF( frame_a8a16c55fe462d4caf5ee4e050c4e1bf );
    }
    cache_frame_a8a16c55fe462d4caf5ee4e050c4e1bf = NULL;

    assertFrameObject( frame_a8a16c55fe462d4caf5ee4e050c4e1bf );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_43__g34 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_43__g34 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_44__g35( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_539df7ba98dcbf44b9cf22062e078c6c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_539df7ba98dcbf44b9cf22062e078c6c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_539df7ba98dcbf44b9cf22062e078c6c, codeobj_539df7ba98dcbf44b9cf22062e078c6c, module_matplotlib$_cm, sizeof(void *) );
    frame_539df7ba98dcbf44b9cf22062e078c6c = cache_frame_539df7ba98dcbf44b9cf22062e078c6c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_539df7ba98dcbf44b9cf22062e078c6c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_539df7ba98dcbf44b9cf22062e078c6c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 157;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_float_0_5;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_FLOAT( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 157;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_539df7ba98dcbf44b9cf22062e078c6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_539df7ba98dcbf44b9cf22062e078c6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_539df7ba98dcbf44b9cf22062e078c6c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_539df7ba98dcbf44b9cf22062e078c6c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_539df7ba98dcbf44b9cf22062e078c6c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_539df7ba98dcbf44b9cf22062e078c6c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_539df7ba98dcbf44b9cf22062e078c6c,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_539df7ba98dcbf44b9cf22062e078c6c == cache_frame_539df7ba98dcbf44b9cf22062e078c6c )
    {
        Py_DECREF( frame_539df7ba98dcbf44b9cf22062e078c6c );
    }
    cache_frame_539df7ba98dcbf44b9cf22062e078c6c = NULL;

    assertFrameObject( frame_539df7ba98dcbf44b9cf22062e078c6c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_44__g35 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_44__g35 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_45__g36( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_34cdfa0db5a804bed374f3274924c102;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_34cdfa0db5a804bed374f3274924c102 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_34cdfa0db5a804bed374f3274924c102, codeobj_34cdfa0db5a804bed374f3274924c102, module_matplotlib$_cm, sizeof(void *) );
    frame_34cdfa0db5a804bed374f3274924c102 = cache_frame_34cdfa0db5a804bed374f3274924c102;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_34cdfa0db5a804bed374f3274924c102 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_34cdfa0db5a804bed374f3274924c102 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 158;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34cdfa0db5a804bed374f3274924c102 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_34cdfa0db5a804bed374f3274924c102 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_34cdfa0db5a804bed374f3274924c102 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_34cdfa0db5a804bed374f3274924c102, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_34cdfa0db5a804bed374f3274924c102->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_34cdfa0db5a804bed374f3274924c102, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_34cdfa0db5a804bed374f3274924c102,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_34cdfa0db5a804bed374f3274924c102 == cache_frame_34cdfa0db5a804bed374f3274924c102 )
    {
        Py_DECREF( frame_34cdfa0db5a804bed374f3274924c102 );
    }
    cache_frame_34cdfa0db5a804bed374f3274924c102 = NULL;

    assertFrameObject( frame_34cdfa0db5a804bed374f3274924c102 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_45__g36 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_45__g36 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_46__gist_heat_red( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_3afce450255723e02f6e0c2dfbb37a63;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3afce450255723e02f6e0c2dfbb37a63 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3afce450255723e02f6e0c2dfbb37a63, codeobj_3afce450255723e02f6e0c2dfbb37a63, module_matplotlib$_cm, sizeof(void *) );
    frame_3afce450255723e02f6e0c2dfbb37a63 = cache_frame_3afce450255723e02f6e0c2dfbb37a63;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3afce450255723e02f6e0c2dfbb37a63 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3afce450255723e02f6e0c2dfbb37a63 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_float_1_5;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_return_value = BINARY_OPERATION_MUL_FLOAT_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1007;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3afce450255723e02f6e0c2dfbb37a63 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_3afce450255723e02f6e0c2dfbb37a63 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3afce450255723e02f6e0c2dfbb37a63 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3afce450255723e02f6e0c2dfbb37a63, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3afce450255723e02f6e0c2dfbb37a63->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3afce450255723e02f6e0c2dfbb37a63, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3afce450255723e02f6e0c2dfbb37a63,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_3afce450255723e02f6e0c2dfbb37a63 == cache_frame_3afce450255723e02f6e0c2dfbb37a63 )
    {
        Py_DECREF( frame_3afce450255723e02f6e0c2dfbb37a63 );
    }
    cache_frame_3afce450255723e02f6e0c2dfbb37a63 = NULL;

    assertFrameObject( frame_3afce450255723e02f6e0c2dfbb37a63 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_46__gist_heat_red );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_46__gist_heat_red );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_47__gist_heat_green( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_c425bfa3b697b36da88d800f6a5f649c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c425bfa3b697b36da88d800f6a5f649c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c425bfa3b697b36da88d800f6a5f649c, codeobj_c425bfa3b697b36da88d800f6a5f649c, module_matplotlib$_cm, sizeof(void *) );
    frame_c425bfa3b697b36da88d800f6a5f649c = cache_frame_c425bfa3b697b36da88d800f6a5f649c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c425bfa3b697b36da88d800f6a5f649c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c425bfa3b697b36da88d800f6a5f649c ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_2;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1008;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_1;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1008;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c425bfa3b697b36da88d800f6a5f649c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c425bfa3b697b36da88d800f6a5f649c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c425bfa3b697b36da88d800f6a5f649c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c425bfa3b697b36da88d800f6a5f649c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c425bfa3b697b36da88d800f6a5f649c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c425bfa3b697b36da88d800f6a5f649c, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c425bfa3b697b36da88d800f6a5f649c,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_c425bfa3b697b36da88d800f6a5f649c == cache_frame_c425bfa3b697b36da88d800f6a5f649c )
    {
        Py_DECREF( frame_c425bfa3b697b36da88d800f6a5f649c );
    }
    cache_frame_c425bfa3b697b36da88d800f6a5f649c = NULL;

    assertFrameObject( frame_c425bfa3b697b36da88d800f6a5f649c );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_47__gist_heat_green );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_47__gist_heat_green );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_48__gist_heat_blue( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_82afbaaa67e636aa043c427e7fdb28c5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_82afbaaa67e636aa043c427e7fdb28c5 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_82afbaaa67e636aa043c427e7fdb28c5, codeobj_82afbaaa67e636aa043c427e7fdb28c5, module_matplotlib$_cm, sizeof(void *) );
    frame_82afbaaa67e636aa043c427e7fdb28c5 = cache_frame_82afbaaa67e636aa043c427e7fdb28c5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_82afbaaa67e636aa043c427e7fdb28c5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_82afbaaa67e636aa043c427e7fdb28c5 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        tmp_left_name_2 = const_int_pos_4;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_left_name_1 = BINARY_OPERATION_MUL_LONG_OBJECT( tmp_left_name_2, tmp_right_name_1 );
        if ( tmp_left_name_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1009;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_int_pos_3;
        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_LONG( tmp_left_name_1, tmp_right_name_2 );
        Py_DECREF( tmp_left_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1009;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_82afbaaa67e636aa043c427e7fdb28c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_82afbaaa67e636aa043c427e7fdb28c5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_82afbaaa67e636aa043c427e7fdb28c5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_82afbaaa67e636aa043c427e7fdb28c5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_82afbaaa67e636aa043c427e7fdb28c5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_82afbaaa67e636aa043c427e7fdb28c5, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_82afbaaa67e636aa043c427e7fdb28c5,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_82afbaaa67e636aa043c427e7fdb28c5 == cache_frame_82afbaaa67e636aa043c427e7fdb28c5 )
    {
        Py_DECREF( frame_82afbaaa67e636aa043c427e7fdb28c5 );
    }
    cache_frame_82afbaaa67e636aa043c427e7fdb28c5 = NULL;

    assertFrameObject( frame_82afbaaa67e636aa043c427e7fdb28c5 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_48__gist_heat_blue );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_48__gist_heat_blue );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}


static PyObject *impl_matplotlib$_cm$$$function_49__gist_yarg( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[ 0 ];
    struct Nuitka_FrameObject *frame_5c7211186caf9b0229bf6a77aa4c1e07;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5c7211186caf9b0229bf6a77aa4c1e07 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5c7211186caf9b0229bf6a77aa4c1e07, codeobj_5c7211186caf9b0229bf6a77aa4c1e07, module_matplotlib$_cm, sizeof(void *) );
    frame_5c7211186caf9b0229bf6a77aa4c1e07 = cache_frame_5c7211186caf9b0229bf6a77aa4c1e07;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5c7211186caf9b0229bf6a77aa4c1e07 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5c7211186caf9b0229bf6a77aa4c1e07 ) == 2 ); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_int_pos_1;
        CHECK_OBJECT( par_x );
        tmp_right_name_1 = par_x;
        tmp_return_value = BINARY_OPERATION_SUB_LONG_OBJECT( tmp_left_name_1, tmp_right_name_1 );
        if ( tmp_return_value == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1088;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5c7211186caf9b0229bf6a77aa4c1e07 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_5c7211186caf9b0229bf6a77aa4c1e07 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5c7211186caf9b0229bf6a77aa4c1e07 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5c7211186caf9b0229bf6a77aa4c1e07, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5c7211186caf9b0229bf6a77aa4c1e07->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5c7211186caf9b0229bf6a77aa4c1e07, exception_lineno );
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5c7211186caf9b0229bf6a77aa4c1e07,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if ( frame_5c7211186caf9b0229bf6a77aa4c1e07 == cache_frame_5c7211186caf9b0229bf6a77aa4c1e07 )
    {
        Py_DECREF( frame_5c7211186caf9b0229bf6a77aa4c1e07 );
    }
    cache_frame_5c7211186caf9b0229bf6a77aa4c1e07 = NULL;

    assertFrameObject( frame_5c7211186caf9b0229bf6a77aa4c1e07 );

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_49__gist_yarg );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT( (PyObject *)par_x );
    Py_DECREF( par_x );
    par_x = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( matplotlib$_cm$$$function_49__gist_yarg );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT( tmp_return_value );
   assert( had_error || !ERROR_OCCURRED() );
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_10__g1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_10__g1,
        const_str_plain__g1,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e6941c21b0200fea6ce96161e8b6c66b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_11__g2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_11__g2,
        const_str_plain__g2,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dada2ba6b2296647be70d287d912eefa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_12__g3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_12__g3,
        const_str_plain__g3,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d9e99e12619d7acd3a9a38a354b64f8a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_13__g4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_13__g4,
        const_str_plain__g4,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5e8fce4fc39e166a2d0361915147e7ca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_14__g5(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_14__g5,
        const_str_plain__g5,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_303af22703fa5d7ab03e56b05a38530a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_15__g6(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_15__g6,
        const_str_plain__g6,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_18b4beebf832bfd38d9855b9aced374d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_16__g7(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_16__g7,
        const_str_plain__g7,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3eb187db916caa0fb065588428c318c1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_17__g8(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_17__g8,
        const_str_plain__g8,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3719f9e14b88827afd13fd07c71d8ae1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_18__g9(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_18__g9,
        const_str_plain__g9,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1c09eff0e45fde6ecde90c7a9f614ba5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_19__g10(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_19__g10,
        const_str_plain__g10,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_55ba6e8ca6ba6f375640e6358def557b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_1__flag_red(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_1__flag_red,
        const_str_plain__flag_red,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6d0d51622009478bd601df761092ef24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_20__g11(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_20__g11,
        const_str_plain__g11,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_53cd0df449e64d7ea7808a94a38ef665,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_21__g12(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_21__g12,
        const_str_plain__g12,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_d63c993436bca5f93a9c78ed99803ff4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_22__g13(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_22__g13,
        const_str_plain__g13,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2852c7d737084fabc63ea0ea210f2aa2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_23__g14(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_23__g14,
        const_str_plain__g14,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9029bab7a1cf5f66c45b951f2c14fbb5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_24__g15(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_24__g15,
        const_str_plain__g15,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_27e2261ab6c9abc0e016656ef2877a5e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_25__g16(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_25__g16,
        const_str_plain__g16,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3eeb63045fca5a861f2fe37fdedc6787,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_26__g17(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_26__g17,
        const_str_plain__g17,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_e119297376def3fb48f19b5a35d19efc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_27__g18(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_27__g18,
        const_str_plain__g18,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_4073d3ca4fbe497a448f547e8ecc72d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_28__g19(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_28__g19,
        const_str_plain__g19,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_8a3cccd29b4301344b470b317d475974,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_29__g20(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_29__g20,
        const_str_plain__g20,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_b5d521e44c58af8e9d25ee8f3491d39e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_2__flag_green(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_2__flag_green,
        const_str_plain__flag_green,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_660ab78476f77e05f409b81259e4d209,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_30__g21(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_30__g21,
        const_str_plain__g21,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3f141603091f9e79166fc67462636516,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_31__g22(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_31__g22,
        const_str_plain__g22,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_71be7a18f282021ca0991601b42aca58,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_32__g23(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_32__g23,
        const_str_plain__g23,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_24fee38c9e266482a2e45eea3fe5f704,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_33__g24(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_33__g24,
        const_str_plain__g24,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_93f63737e8d01a5e712320109901c660,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_34__g25(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_34__g25,
        const_str_plain__g25,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_9a049aa6ab7d4ac8f3db952c101016b3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_35__g26(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_35__g26,
        const_str_plain__g26,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_59430b3c1d9efa7f67144ba688bce895,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_36__g27(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_36__g27,
        const_str_plain__g27,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2e9d0097cf3c6357824a05b9a838d1ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_37__g28(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_37__g28,
        const_str_plain__g28,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_560516ef25ad4926357a26fe2e0ee1fe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_38__g29(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_38__g29,
        const_str_plain__g29,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_dab820f0e92ed8284b12269dc4bb5313,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_39__g30(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_39__g30,
        const_str_plain__g30,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6eba6b875aee118971f5958bd375cae4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_3__flag_blue(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_3__flag_blue,
        const_str_plain__flag_blue,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_7e91d725aa9c77656e205bb95c4e45a3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_40__g31(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_40__g31,
        const_str_plain__g31,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_56c9d341f43b8152629e1d5e5810ecb3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_41__g32(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_41__g32,
        const_str_plain__g32,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_1d722020af9b4fc79a1556ef37f5760e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_42__g33(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_42__g33,
        const_str_plain__g33,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_274d1243a2ef895f960c92b92c710875,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_43__g34(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_43__g34,
        const_str_plain__g34,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a8a16c55fe462d4caf5ee4e050c4e1bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_44__g35(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_44__g35,
        const_str_plain__g35,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_539df7ba98dcbf44b9cf22062e078c6c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_45__g36(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_45__g36,
        const_str_plain__g36,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_34cdfa0db5a804bed374f3274924c102,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_46__gist_heat_red(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_46__gist_heat_red,
        const_str_plain__gist_heat_red,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3afce450255723e02f6e0c2dfbb37a63,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_47__gist_heat_green(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_47__gist_heat_green,
        const_str_plain__gist_heat_green,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_c425bfa3b697b36da88d800f6a5f649c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_48__gist_heat_blue(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_48__gist_heat_blue,
        const_str_plain__gist_heat_blue,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_82afbaaa67e636aa043c427e7fdb28c5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_49__gist_yarg(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_49__gist_yarg,
        const_str_plain__gist_yarg,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_5c7211186caf9b0229bf6a77aa4c1e07,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_4__prism_red(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_4__prism_red,
        const_str_plain__prism_red,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_351882a054fb67563edba00f287e656d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_5__prism_green(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_5__prism_green,
        const_str_plain__prism_green,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_cd24745a8a3faf93f9e789c7a6bb948f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_6__prism_blue(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_6__prism_blue,
        const_str_plain__prism_blue,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_2f98b0c828fcabf21378573c27697830,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_7__ch_helper(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_7__ch_helper,
        const_str_plain__ch_helper,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_3a3a75eacc017b030677b4c53ee5ee6f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        const_str_digest_0870d49f1cf88348cb56a7f4adc73408,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_8_cubehelix( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_8_cubehelix,
        const_str_plain_cubehelix,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_6178e17e4d40750a1307d73e08fbfc0a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        const_str_digest_68bcfeed91a2fbe6bb71f773db17210e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_matplotlib$_cm$$$function_9__g0(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_matplotlib$_cm$$$function_9__g0,
        const_str_plain__g0,
#if PYTHON_VERSION >= 300
        NULL,
#endif
        codeobj_a82d4e3c4a8d0bfd42dc1adc809d58dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_matplotlib$_cm,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_matplotlib$_cm =
{
    PyModuleDef_HEAD_INIT,
    "matplotlib._cm",
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( matplotlib$_cm )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_matplotlib$_cm );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // May have to activate constants blob.
#if defined(_NUITKA_CONSTANTS_FROM_RESOURCE)
    loadConstantsResource();
#endif

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    puts("matplotlib._cm: Calling setupMetaPathBasedLoader().");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("matplotlib._cm: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("matplotlib._cm: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initmatplotlib$_cm" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_matplotlib$_cm = Py_InitModule4(
        "matplotlib._cm",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else

    module_matplotlib$_cm = PyModule_Create( &mdef_matplotlib$_cm );
#endif

    moduledict_matplotlib$_cm = MODULE_DICT( module_matplotlib$_cm );

    // Set __compiled__ to what it we know.
    UPDATE_STRING_DICT1(
        moduledict_matplotlib$_cm,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___name__ );

        UPDATE_STRING_DICT1(
            moduledict_matplotlib$_cm,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___name__ );
        char const *module_name_cstr = PyString_AS_STRING( module_name );

        char const *last_dot = strrchr( module_name_cstr, '.' );

        if ( last_dot != NULL )
        {
            UPDATE_STRING_DICT1(
                moduledict_matplotlib$_cm,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize( module_name_cstr, last_dot - module_name_cstr )
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___name__ );
        Py_ssize_t dot_index = PyUnicode_Find( module_name, const_str_dot, 0, PyUnicode_GetLength( module_name ), -1 );

        if ( dot_index != -1 )
        {
            UPDATE_STRING_DICT1(
                moduledict_matplotlib$_cm,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring( module_name, 0, dot_index )
            );
        }
#endif
#endif
    }

    CHECK_OBJECT( module_matplotlib$_cm );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PyImport_GetModuleDict(), const_str_digest_70f25990f64eb086931fae485976330d, module_matplotlib$_cm );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if ( GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___builtins__, value );
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type );
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___spec__, Py_None );
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT( bootstrap_module );
        PyObject *module_spec_class = PyObject_GetAttrString( bootstrap_module, "ModuleSpec" );
        Py_DECREF( bootstrap_module );

        PyObject *args[] = {
            GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___name__ ),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF( module_spec_class );

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT( spec_value );

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE( spec_value, const_str_plain_submodule_search_locations, PyList_New(0) );
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE( spec_value, const_str_plain__initializing, Py_True );

        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___spec__, spec_value );
    }
#endif
#endif

    // Temp variables if any
    PyObject *outline_0_var_i = NULL;
    PyObject *tmp_dictcontraction_1__$0 = NULL;
    PyObject *tmp_dictcontraction_1__contraction = NULL;
    PyObject *tmp_dictcontraction_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_7ca714f50dd5177aff8ddf15c2af89b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    struct Nuitka_FrameObject *frame_dd80d34bc48fe593d7452b7382f30673_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_dd80d34bc48fe593d7452b7382f30673_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_str_digest_0ec62d994d1e365c7efad4dabaaba134;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = module_filename_obj;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    }
    // Frame without reuse.
    frame_7ca714f50dd5177aff8ddf15c2af89b0 = MAKE_MODULE_FRAME( codeobj_7ca714f50dd5177aff8ddf15c2af89b0, module_matplotlib$_cm );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_7ca714f50dd5177aff8ddf15c2af89b0 );
    assert( Py_REFCNT( frame_7ca714f50dd5177aff8ddf15c2af89b0 ) == 2 );

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_mvar_value_1;
        tmp_assattr_name_1 = module_filename_obj;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___spec__ );

        if (unlikely( tmp_mvar_value_1 == NULL ))
        {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__ );
        }

        CHECK_OBJECT( tmp_mvar_value_1 );
        tmp_assattr_target_1 = tmp_mvar_value_1;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_origin, tmp_assattr_name_1 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_mvar_value_2;
        tmp_assattr_name_2 = Py_True;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___spec__ );

        if (unlikely( tmp_mvar_value_2 == NULL ))
        {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__ );
        }

        CHECK_OBJECT( tmp_mvar_value_2 );
        tmp_assattr_target_2 = tmp_mvar_value_2;
        tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_has_location, tmp_assattr_name_2 );
        if ( tmp_result == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = Py_None;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3 );
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_plain_functools;
        tmp_globals_name_1 = (PyObject *)moduledict_matplotlib$_cm;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_partial_tuple;
        tmp_level_name_1 = const_int_0;
        frame_7ca714f50dd5177aff8ddf15c2af89b0->m_frame.f_lineno = 9;
        tmp_import_name_from_1 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
        if ( tmp_import_name_from_1 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_partial );
        Py_DECREF( tmp_import_name_from_1 );
        if ( tmp_assign_source_4 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_partial, tmp_assign_source_4 );
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_plain_numpy;
        tmp_globals_name_2 = (PyObject *)moduledict_matplotlib$_cm;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        tmp_level_name_2 = const_int_0;
        frame_7ca714f50dd5177aff8ddf15c2af89b0->m_frame.f_lineno = 11;
        tmp_assign_source_5 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
        if ( tmp_assign_source_5 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_np, tmp_assign_source_5 );
    }
    {
        PyObject *tmp_assign_source_6;
        tmp_assign_source_6 = PyDict_Copy( const_dict_139fa967a21793ecdbc3e590120916a2 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__binary_data, tmp_assign_source_6 );
    }
    {
        PyObject *tmp_assign_source_7;
        tmp_assign_source_7 = PyDict_Copy( const_dict_61e4a4a8cd2b4181694d4cfb1751640d );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__autumn_data, tmp_assign_source_7 );
    }
    {
        PyObject *tmp_assign_source_8;
        tmp_assign_source_8 = PyDict_Copy( const_dict_e67366b36b736b2b1824e4124103e620 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__bone_data, tmp_assign_source_8 );
    }
    {
        PyObject *tmp_assign_source_9;
        tmp_assign_source_9 = PyDict_Copy( const_dict_3adc72b697f1d7d162e0d950131b4b5a );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__cool_data, tmp_assign_source_9 );
    }
    {
        PyObject *tmp_assign_source_10;
        tmp_assign_source_10 = PyDict_Copy( const_dict_8f097861f42f3010bd8f6de6022ffc3c );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__copper_data, tmp_assign_source_10 );
    }
    {
        PyObject *tmp_assign_source_11;
        tmp_assign_source_11 = MAKE_FUNCTION_matplotlib$_cm$$$function_1__flag_red(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_red, tmp_assign_source_11 );
    }
    {
        PyObject *tmp_assign_source_12;
        tmp_assign_source_12 = MAKE_FUNCTION_matplotlib$_cm$$$function_2__flag_green(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_green, tmp_assign_source_12 );
    }
    {
        PyObject *tmp_assign_source_13;
        tmp_assign_source_13 = MAKE_FUNCTION_matplotlib$_cm$$$function_3__flag_blue(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_blue, tmp_assign_source_13 );
    }
    {
        PyObject *tmp_assign_source_14;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_mvar_value_5;
        tmp_dict_key_1 = const_str_plain_red;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_red );

        if (unlikely( tmp_mvar_value_3 == NULL ))
        {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__flag_red );
        }

        CHECK_OBJECT( tmp_mvar_value_3 );
        tmp_dict_value_1 = tmp_mvar_value_3;
        tmp_assign_source_14 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_14, tmp_dict_key_1, tmp_dict_value_1 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_2 = const_str_plain_green;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_green );

        if (unlikely( tmp_mvar_value_4 == NULL ))
        {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__flag_green );
        }

        CHECK_OBJECT( tmp_mvar_value_4 );
        tmp_dict_value_2 = tmp_mvar_value_4;
        tmp_res = PyDict_SetItem( tmp_assign_source_14, tmp_dict_key_2, tmp_dict_value_2 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_3 = const_str_plain_blue;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_blue );

        if (unlikely( tmp_mvar_value_5 == NULL ))
        {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__flag_blue );
        }

        CHECK_OBJECT( tmp_mvar_value_5 );
        tmp_dict_value_3 = tmp_mvar_value_5;
        tmp_res = PyDict_SetItem( tmp_assign_source_14, tmp_dict_key_3, tmp_dict_value_3 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_data, tmp_assign_source_14 );
    }
    {
        PyObject *tmp_assign_source_15;
        tmp_assign_source_15 = MAKE_FUNCTION_matplotlib$_cm$$$function_4__prism_red(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_red, tmp_assign_source_15 );
    }
    {
        PyObject *tmp_assign_source_16;
        tmp_assign_source_16 = MAKE_FUNCTION_matplotlib$_cm$$$function_5__prism_green(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_green, tmp_assign_source_16 );
    }
    {
        PyObject *tmp_assign_source_17;
        tmp_assign_source_17 = MAKE_FUNCTION_matplotlib$_cm$$$function_6__prism_blue(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_blue, tmp_assign_source_17 );
    }
    {
        PyObject *tmp_assign_source_18;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_mvar_value_6;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_dict_key_6;
        PyObject *tmp_dict_value_6;
        PyObject *tmp_mvar_value_8;
        tmp_dict_key_4 = const_str_plain_red;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_red );

        if (unlikely( tmp_mvar_value_6 == NULL ))
        {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__prism_red );
        }

        CHECK_OBJECT( tmp_mvar_value_6 );
        tmp_dict_value_4 = tmp_mvar_value_6;
        tmp_assign_source_18 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_18, tmp_dict_key_4, tmp_dict_value_4 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_5 = const_str_plain_green;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_green );

        if (unlikely( tmp_mvar_value_7 == NULL ))
        {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__prism_green );
        }

        CHECK_OBJECT( tmp_mvar_value_7 );
        tmp_dict_value_5 = tmp_mvar_value_7;
        tmp_res = PyDict_SetItem( tmp_assign_source_18, tmp_dict_key_5, tmp_dict_value_5 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_6 = const_str_plain_blue;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_blue );

        if (unlikely( tmp_mvar_value_8 == NULL ))
        {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__prism_blue );
        }

        CHECK_OBJECT( tmp_mvar_value_8 );
        tmp_dict_value_6 = tmp_mvar_value_8;
        tmp_res = PyDict_SetItem( tmp_assign_source_18, tmp_dict_key_6, tmp_dict_value_6 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_data, tmp_assign_source_18 );
    }
    {
        PyObject *tmp_assign_source_19;
        tmp_assign_source_19 = MAKE_FUNCTION_matplotlib$_cm$$$function_7__ch_helper(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__ch_helper, tmp_assign_source_19 );
    }
    {
        PyObject *tmp_assign_source_20;
        PyObject *tmp_defaults_1;
        tmp_defaults_1 = const_tuple_float_1_0_float_0_5_float_minus_1_5_float_1_0_tuple;
        Py_INCREF( tmp_defaults_1 );
        tmp_assign_source_20 = MAKE_FUNCTION_matplotlib$_cm$$$function_8_cubehelix( tmp_defaults_1 );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_cubehelix, tmp_assign_source_20 );
    }
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_cubehelix );

        if (unlikely( tmp_mvar_value_9 == NULL ))
        {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_cubehelix );
        }

        CHECK_OBJECT( tmp_mvar_value_9 );
        tmp_called_name_1 = tmp_mvar_value_9;
        frame_7ca714f50dd5177aff8ddf15c2af89b0->m_frame.f_lineno = 108;
        tmp_assign_source_21 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
        if ( tmp_assign_source_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 108;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__cubehelix_data, tmp_assign_source_21 );
    }
    {
        PyObject *tmp_assign_source_22;
        tmp_assign_source_22 = const_tuple_2bea485d544db289d067c788ebf78b62_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__bwr_data, tmp_assign_source_22 );
    }
    {
        PyObject *tmp_assign_source_23;
        tmp_assign_source_23 = const_tuple_a22c772c730dca9240495aa06353c5e0_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__brg_data, tmp_assign_source_23 );
    }
    {
        PyObject *tmp_assign_source_24;
        tmp_assign_source_24 = MAKE_FUNCTION_matplotlib$_cm$$$function_9__g0(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g0, tmp_assign_source_24 );
    }
    {
        PyObject *tmp_assign_source_25;
        tmp_assign_source_25 = MAKE_FUNCTION_matplotlib$_cm$$$function_10__g1(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g1, tmp_assign_source_25 );
    }
    {
        PyObject *tmp_assign_source_26;
        tmp_assign_source_26 = MAKE_FUNCTION_matplotlib$_cm$$$function_11__g2(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g2, tmp_assign_source_26 );
    }
    {
        PyObject *tmp_assign_source_27;
        tmp_assign_source_27 = MAKE_FUNCTION_matplotlib$_cm$$$function_12__g3(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g3, tmp_assign_source_27 );
    }
    {
        PyObject *tmp_assign_source_28;
        tmp_assign_source_28 = MAKE_FUNCTION_matplotlib$_cm$$$function_13__g4(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g4, tmp_assign_source_28 );
    }
    {
        PyObject *tmp_assign_source_29;
        tmp_assign_source_29 = MAKE_FUNCTION_matplotlib$_cm$$$function_14__g5(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g5, tmp_assign_source_29 );
    }
    {
        PyObject *tmp_assign_source_30;
        tmp_assign_source_30 = MAKE_FUNCTION_matplotlib$_cm$$$function_15__g6(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g6, tmp_assign_source_30 );
    }
    {
        PyObject *tmp_assign_source_31;
        tmp_assign_source_31 = MAKE_FUNCTION_matplotlib$_cm$$$function_16__g7(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g7, tmp_assign_source_31 );
    }
    {
        PyObject *tmp_assign_source_32;
        tmp_assign_source_32 = MAKE_FUNCTION_matplotlib$_cm$$$function_17__g8(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g8, tmp_assign_source_32 );
    }
    {
        PyObject *tmp_assign_source_33;
        tmp_assign_source_33 = MAKE_FUNCTION_matplotlib$_cm$$$function_18__g9(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g9, tmp_assign_source_33 );
    }
    {
        PyObject *tmp_assign_source_34;
        tmp_assign_source_34 = MAKE_FUNCTION_matplotlib$_cm$$$function_19__g10(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g10, tmp_assign_source_34 );
    }
    {
        PyObject *tmp_assign_source_35;
        tmp_assign_source_35 = MAKE_FUNCTION_matplotlib$_cm$$$function_20__g11(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g11, tmp_assign_source_35 );
    }
    {
        PyObject *tmp_assign_source_36;
        tmp_assign_source_36 = MAKE_FUNCTION_matplotlib$_cm$$$function_21__g12(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g12, tmp_assign_source_36 );
    }
    {
        PyObject *tmp_assign_source_37;
        tmp_assign_source_37 = MAKE_FUNCTION_matplotlib$_cm$$$function_22__g13(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g13, tmp_assign_source_37 );
    }
    {
        PyObject *tmp_assign_source_38;
        tmp_assign_source_38 = MAKE_FUNCTION_matplotlib$_cm$$$function_23__g14(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g14, tmp_assign_source_38 );
    }
    {
        PyObject *tmp_assign_source_39;
        tmp_assign_source_39 = MAKE_FUNCTION_matplotlib$_cm$$$function_24__g15(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g15, tmp_assign_source_39 );
    }
    {
        PyObject *tmp_assign_source_40;
        tmp_assign_source_40 = MAKE_FUNCTION_matplotlib$_cm$$$function_25__g16(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g16, tmp_assign_source_40 );
    }
    {
        PyObject *tmp_assign_source_41;
        tmp_assign_source_41 = MAKE_FUNCTION_matplotlib$_cm$$$function_26__g17(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g17, tmp_assign_source_41 );
    }
    {
        PyObject *tmp_assign_source_42;
        tmp_assign_source_42 = MAKE_FUNCTION_matplotlib$_cm$$$function_27__g18(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g18, tmp_assign_source_42 );
    }
    {
        PyObject *tmp_assign_source_43;
        tmp_assign_source_43 = MAKE_FUNCTION_matplotlib$_cm$$$function_28__g19(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g19, tmp_assign_source_43 );
    }
    {
        PyObject *tmp_assign_source_44;
        tmp_assign_source_44 = MAKE_FUNCTION_matplotlib$_cm$$$function_29__g20(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g20, tmp_assign_source_44 );
    }
    {
        PyObject *tmp_assign_source_45;
        tmp_assign_source_45 = MAKE_FUNCTION_matplotlib$_cm$$$function_30__g21(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g21, tmp_assign_source_45 );
    }
    {
        PyObject *tmp_assign_source_46;
        tmp_assign_source_46 = MAKE_FUNCTION_matplotlib$_cm$$$function_31__g22(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g22, tmp_assign_source_46 );
    }
    {
        PyObject *tmp_assign_source_47;
        tmp_assign_source_47 = MAKE_FUNCTION_matplotlib$_cm$$$function_32__g23(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g23, tmp_assign_source_47 );
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = MAKE_FUNCTION_matplotlib$_cm$$$function_33__g24(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g24, tmp_assign_source_48 );
    }
    {
        PyObject *tmp_assign_source_49;
        tmp_assign_source_49 = MAKE_FUNCTION_matplotlib$_cm$$$function_34__g25(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g25, tmp_assign_source_49 );
    }
    {
        PyObject *tmp_assign_source_50;
        tmp_assign_source_50 = MAKE_FUNCTION_matplotlib$_cm$$$function_35__g26(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g26, tmp_assign_source_50 );
    }
    {
        PyObject *tmp_assign_source_51;
        tmp_assign_source_51 = MAKE_FUNCTION_matplotlib$_cm$$$function_36__g27(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g27, tmp_assign_source_51 );
    }
    {
        PyObject *tmp_assign_source_52;
        tmp_assign_source_52 = MAKE_FUNCTION_matplotlib$_cm$$$function_37__g28(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g28, tmp_assign_source_52 );
    }
    {
        PyObject *tmp_assign_source_53;
        tmp_assign_source_53 = MAKE_FUNCTION_matplotlib$_cm$$$function_38__g29(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g29, tmp_assign_source_53 );
    }
    {
        PyObject *tmp_assign_source_54;
        tmp_assign_source_54 = MAKE_FUNCTION_matplotlib$_cm$$$function_39__g30(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g30, tmp_assign_source_54 );
    }
    {
        PyObject *tmp_assign_source_55;
        tmp_assign_source_55 = MAKE_FUNCTION_matplotlib$_cm$$$function_40__g31(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g31, tmp_assign_source_55 );
    }
    {
        PyObject *tmp_assign_source_56;
        tmp_assign_source_56 = MAKE_FUNCTION_matplotlib$_cm$$$function_41__g32(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g32, tmp_assign_source_56 );
    }
    {
        PyObject *tmp_assign_source_57;
        tmp_assign_source_57 = MAKE_FUNCTION_matplotlib$_cm$$$function_42__g33(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g33, tmp_assign_source_57 );
    }
    {
        PyObject *tmp_assign_source_58;
        tmp_assign_source_58 = MAKE_FUNCTION_matplotlib$_cm$$$function_43__g34(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g34, tmp_assign_source_58 );
    }
    {
        PyObject *tmp_assign_source_59;
        tmp_assign_source_59 = MAKE_FUNCTION_matplotlib$_cm$$$function_44__g35(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g35, tmp_assign_source_59 );
    }
    {
        PyObject *tmp_assign_source_60;
        tmp_assign_source_60 = MAKE_FUNCTION_matplotlib$_cm$$$function_45__g36(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__g36, tmp_assign_source_60 );
    }
    {
        PyObject *tmp_assign_source_61;
        {
            PyObject *tmp_assign_source_62;
            PyObject *tmp_iter_arg_1;
            tmp_iter_arg_1 = const_xrange_0_37;
            tmp_assign_source_62 = MAKE_ITERATOR( tmp_iter_arg_1 );
            assert( !(tmp_assign_source_62 == NULL) );
            assert( tmp_dictcontraction_1__$0 == NULL );
            tmp_dictcontraction_1__$0 = tmp_assign_source_62;
        }
        {
            PyObject *tmp_assign_source_63;
            tmp_assign_source_63 = PyDict_New();
            assert( tmp_dictcontraction_1__contraction == NULL );
            tmp_dictcontraction_1__contraction = tmp_assign_source_63;
        }
        // Tried code:
        MAKE_OR_REUSE_FRAME( cache_frame_dd80d34bc48fe593d7452b7382f30673_2, codeobj_dd80d34bc48fe593d7452b7382f30673, module_matplotlib$_cm, sizeof(void *) );
        frame_dd80d34bc48fe593d7452b7382f30673_2 = cache_frame_dd80d34bc48fe593d7452b7382f30673_2;

        // Push the new frame as the currently active one.
        pushFrameStack( frame_dd80d34bc48fe593d7452b7382f30673_2 );

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert( Py_REFCNT( frame_dd80d34bc48fe593d7452b7382f30673_2 ) == 2 ); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_64;
            CHECK_OBJECT( tmp_dictcontraction_1__$0 );
            tmp_next_source_1 = tmp_dictcontraction_1__$0;
            tmp_assign_source_64 = ITERATOR_NEXT( tmp_next_source_1 );
            if ( tmp_assign_source_64 == NULL )
            {
                if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
                {

                    goto loop_end_1;
                }
                else
                {

                    FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
                    type_description_2 = "o";
                    exception_lineno = 160;
                    goto try_except_handler_2;
                }
            }

            {
                PyObject *old = tmp_dictcontraction_1__iter_value_0;
                tmp_dictcontraction_1__iter_value_0 = tmp_assign_source_64;
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_assign_source_65;
            CHECK_OBJECT( tmp_dictcontraction_1__iter_value_0 );
            tmp_assign_source_65 = tmp_dictcontraction_1__iter_value_0;
            {
                PyObject *old = outline_0_var_i;
                outline_0_var_i = tmp_assign_source_65;
                Py_INCREF( outline_0_var_i );
                Py_XDECREF( old );
            }

        }
        {
            PyObject *tmp_subscribed_name_1;
            PyObject *tmp_subscript_name_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            tmp_subscribed_name_1 = (PyObject *)moduledict_matplotlib$_cm;
            tmp_called_instance_1 = const_str_digest_f73618ed65447e45c026300593ea43e2;
            CHECK_OBJECT( outline_0_var_i );
            tmp_args_element_name_1 = outline_0_var_i;
            frame_dd80d34bc48fe593d7452b7382f30673_2->m_frame.f_lineno = 160;
            {
                PyObject *call_args[] = { tmp_args_element_name_1 };
                tmp_subscript_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_format, call_args );
            }

            if ( tmp_subscript_name_1 == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 160;
                type_description_2 = "o";
                goto try_except_handler_2;
            }
            tmp_dictset_value = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
            Py_DECREF( tmp_subscript_name_1 );
            if ( tmp_dictset_value == NULL )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 160;
                type_description_2 = "o";
                goto try_except_handler_2;
            }
            CHECK_OBJECT( tmp_dictcontraction_1__contraction );
            tmp_dictset_dict = tmp_dictcontraction_1__contraction;
            CHECK_OBJECT( outline_0_var_i );
            tmp_dictset_key = outline_0_var_i;
            tmp_res = PyDict_SetItem( tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value );
            Py_DECREF( tmp_dictset_value );
            if ( tmp_res != 0 )
            {
                assert( ERROR_OCCURRED() );

                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                exception_lineno = 160;
                type_description_2 = "o";
                goto try_except_handler_2;
            }
        }
        if ( CONSIDER_THREADING() == false )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 160;
            type_description_2 = "o";
            goto try_except_handler_2;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT( tmp_dictcontraction_1__contraction );
        tmp_assign_source_61 = tmp_dictcontraction_1__contraction;
        Py_INCREF( tmp_assign_source_61 );
        goto try_return_handler_2;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( matplotlib$_cm );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__$0 );
        Py_DECREF( tmp_dictcontraction_1__$0 );
        tmp_dictcontraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__contraction );
        Py_DECREF( tmp_dictcontraction_1__contraction );
        tmp_dictcontraction_1__contraction = NULL;

        Py_XDECREF( tmp_dictcontraction_1__iter_value_0 );
        tmp_dictcontraction_1__iter_value_0 = NULL;

        goto frame_return_exit_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__$0 );
        Py_DECREF( tmp_dictcontraction_1__$0 );
        tmp_dictcontraction_1__$0 = NULL;

        CHECK_OBJECT( (PyObject *)tmp_dictcontraction_1__contraction );
        Py_DECREF( tmp_dictcontraction_1__contraction );
        tmp_dictcontraction_1__contraction = NULL;

        Py_XDECREF( tmp_dictcontraction_1__iter_value_0 );
        tmp_dictcontraction_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION( frame_dd80d34bc48fe593d7452b7382f30673_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_1:;
#if 0
        RESTORE_FRAME_EXCEPTION( frame_dd80d34bc48fe593d7452b7382f30673_2 );
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION( frame_dd80d34bc48fe593d7452b7382f30673_2 );
#endif

        if ( exception_tb == NULL )
        {
            exception_tb = MAKE_TRACEBACK( frame_dd80d34bc48fe593d7452b7382f30673_2, exception_lineno );
        }
        else if ( exception_tb->tb_frame != &frame_dd80d34bc48fe593d7452b7382f30673_2->m_frame )
        {
            exception_tb = ADD_TRACEBACK( exception_tb, frame_dd80d34bc48fe593d7452b7382f30673_2, exception_lineno );
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_dd80d34bc48fe593d7452b7382f30673_2,
            type_description_2,
            outline_0_var_i
        );


        // Release cached frame.
        if ( frame_dd80d34bc48fe593d7452b7382f30673_2 == cache_frame_dd80d34bc48fe593d7452b7382f30673_2 )
        {
            Py_DECREF( frame_dd80d34bc48fe593d7452b7382f30673_2 );
        }
        cache_frame_dd80d34bc48fe593d7452b7382f30673_2 = NULL;

        assertFrameObject( frame_dd80d34bc48fe593d7452b7382f30673_2 );

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_1;
        skip_nested_handling_1:;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE( matplotlib$_cm );
        return MOD_RETURN_VALUE( NULL );
        // Return handler code:
        try_return_handler_1:;
        Py_XDECREF( outline_0_var_i );
        outline_0_var_i = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_1:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF( outline_0_var_i );
        outline_0_var_i = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE( matplotlib$_cm );
        return MOD_RETURN_VALUE( NULL );
        outline_exception_1:;
        exception_lineno = 160;
        goto frame_exception_exit_1;
        outline_result_1:;
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc, tmp_assign_source_61 );
    }
    {
        PyObject *tmp_assign_source_66;
        PyObject *tmp_dict_key_7;
        PyObject *tmp_dict_value_7;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_dict_key_8;
        PyObject *tmp_dict_value_8;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_mvar_value_11;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_dict_key_9;
        PyObject *tmp_dict_value_9;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_mvar_value_12;
        PyObject *tmp_subscript_name_4;
        tmp_dict_key_7 = const_str_plain_red;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_10 == NULL ))
        {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        CHECK_OBJECT( tmp_mvar_value_10 );
        tmp_subscribed_name_2 = tmp_mvar_value_10;
        tmp_subscript_name_2 = const_int_pos_7;
        tmp_dict_value_7 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_2, tmp_subscript_name_2, 7 );
        if ( tmp_dict_value_7 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 163;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_66 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_66, tmp_dict_key_7, tmp_dict_value_7 );
        Py_DECREF( tmp_dict_value_7 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_8 = const_str_plain_green;
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_11 == NULL ))
        {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_11 == NULL )
        {
            Py_DECREF( tmp_assign_source_66 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 164;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_3 = tmp_mvar_value_11;
        tmp_subscript_name_3 = const_int_pos_5;
        tmp_dict_value_8 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_3, tmp_subscript_name_3, 5 );
        if ( tmp_dict_value_8 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_66 );

            exception_lineno = 164;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_66, tmp_dict_key_8, tmp_dict_value_8 );
        Py_DECREF( tmp_dict_value_8 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_9 = const_str_plain_blue;
        tmp_mvar_value_12 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_12 == NULL ))
        {
            tmp_mvar_value_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_12 == NULL )
        {
            Py_DECREF( tmp_assign_source_66 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 165;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_4 = tmp_mvar_value_12;
        tmp_subscript_name_4 = const_int_pos_15;
        tmp_dict_value_9 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_4, tmp_subscript_name_4, 15 );
        if ( tmp_dict_value_9 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_66 );

            exception_lineno = 165;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_66, tmp_dict_key_9, tmp_dict_value_9 );
        Py_DECREF( tmp_dict_value_9 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gnuplot_data, tmp_assign_source_66 );
    }
    {
        PyObject *tmp_assign_source_67;
        PyObject *tmp_dict_key_10;
        PyObject *tmp_dict_value_10;
        PyObject *tmp_subscribed_name_5;
        PyObject *tmp_mvar_value_13;
        PyObject *tmp_subscript_name_5;
        PyObject *tmp_dict_key_11;
        PyObject *tmp_dict_value_11;
        PyObject *tmp_subscribed_name_6;
        PyObject *tmp_mvar_value_14;
        PyObject *tmp_subscript_name_6;
        PyObject *tmp_dict_key_12;
        PyObject *tmp_dict_value_12;
        PyObject *tmp_subscribed_name_7;
        PyObject *tmp_mvar_value_15;
        PyObject *tmp_subscript_name_7;
        tmp_dict_key_10 = const_str_plain_red;
        tmp_mvar_value_13 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_13 == NULL ))
        {
            tmp_mvar_value_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_13 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 169;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_5 = tmp_mvar_value_13;
        tmp_subscript_name_5 = const_int_pos_30;
        tmp_dict_value_10 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_5, tmp_subscript_name_5, 30 );
        if ( tmp_dict_value_10 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 169;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_67 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_67, tmp_dict_key_10, tmp_dict_value_10 );
        Py_DECREF( tmp_dict_value_10 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_11 = const_str_plain_green;
        tmp_mvar_value_14 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_14 == NULL ))
        {
            tmp_mvar_value_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_14 == NULL )
        {
            Py_DECREF( tmp_assign_source_67 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 170;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_6 = tmp_mvar_value_14;
        tmp_subscript_name_6 = const_int_pos_31;
        tmp_dict_value_11 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_6, tmp_subscript_name_6, 31 );
        if ( tmp_dict_value_11 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_67 );

            exception_lineno = 170;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_67, tmp_dict_key_11, tmp_dict_value_11 );
        Py_DECREF( tmp_dict_value_11 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_12 = const_str_plain_blue;
        tmp_mvar_value_15 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_15 == NULL ))
        {
            tmp_mvar_value_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_15 == NULL )
        {
            Py_DECREF( tmp_assign_source_67 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 171;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_7 = tmp_mvar_value_15;
        tmp_subscript_name_7 = const_int_pos_32;
        tmp_dict_value_12 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_7, tmp_subscript_name_7, 32 );
        if ( tmp_dict_value_12 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_67 );

            exception_lineno = 171;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_67, tmp_dict_key_12, tmp_dict_value_12 );
        Py_DECREF( tmp_dict_value_12 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gnuplot2_data, tmp_assign_source_67 );
    }
    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_dict_key_13;
        PyObject *tmp_dict_value_13;
        PyObject *tmp_subscribed_name_8;
        PyObject *tmp_mvar_value_16;
        PyObject *tmp_subscript_name_8;
        PyObject *tmp_dict_key_14;
        PyObject *tmp_dict_value_14;
        PyObject *tmp_subscribed_name_9;
        PyObject *tmp_mvar_value_17;
        PyObject *tmp_subscript_name_9;
        PyObject *tmp_dict_key_15;
        PyObject *tmp_dict_value_15;
        PyObject *tmp_subscribed_name_10;
        PyObject *tmp_mvar_value_18;
        PyObject *tmp_subscript_name_10;
        tmp_dict_key_13 = const_str_plain_red;
        tmp_mvar_value_16 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_16 == NULL ))
        {
            tmp_mvar_value_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 175;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_8 = tmp_mvar_value_16;
        tmp_subscript_name_8 = const_int_pos_23;
        tmp_dict_value_13 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_8, tmp_subscript_name_8, 23 );
        if ( tmp_dict_value_13 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 175;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_68 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_68, tmp_dict_key_13, tmp_dict_value_13 );
        Py_DECREF( tmp_dict_value_13 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_14 = const_str_plain_green;
        tmp_mvar_value_17 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_17 == NULL ))
        {
            tmp_mvar_value_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_17 == NULL )
        {
            Py_DECREF( tmp_assign_source_68 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 176;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_9 = tmp_mvar_value_17;
        tmp_subscript_name_9 = const_int_pos_28;
        tmp_dict_value_14 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_9, tmp_subscript_name_9, 28 );
        if ( tmp_dict_value_14 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_68 );

            exception_lineno = 176;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_68, tmp_dict_key_14, tmp_dict_value_14 );
        Py_DECREF( tmp_dict_value_14 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_15 = const_str_plain_blue;
        tmp_mvar_value_18 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_18 == NULL ))
        {
            tmp_mvar_value_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_18 == NULL )
        {
            Py_DECREF( tmp_assign_source_68 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 177;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_10 = tmp_mvar_value_18;
        tmp_subscript_name_10 = const_int_pos_3;
        tmp_dict_value_15 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_10, tmp_subscript_name_10, 3 );
        if ( tmp_dict_value_15 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_68 );

            exception_lineno = 177;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_68, tmp_dict_key_15, tmp_dict_value_15 );
        Py_DECREF( tmp_dict_value_15 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__ocean_data, tmp_assign_source_68 );
    }
    {
        PyObject *tmp_assign_source_69;
        PyObject *tmp_dict_key_16;
        PyObject *tmp_dict_value_16;
        PyObject *tmp_subscribed_name_11;
        PyObject *tmp_mvar_value_19;
        PyObject *tmp_subscript_name_11;
        PyObject *tmp_dict_key_17;
        PyObject *tmp_dict_value_17;
        PyObject *tmp_subscribed_name_12;
        PyObject *tmp_mvar_value_20;
        PyObject *tmp_subscript_name_12;
        PyObject *tmp_dict_key_18;
        PyObject *tmp_dict_value_18;
        PyObject *tmp_subscribed_name_13;
        PyObject *tmp_mvar_value_21;
        PyObject *tmp_subscript_name_13;
        tmp_dict_key_16 = const_str_plain_red;
        tmp_mvar_value_19 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_19 == NULL ))
        {
            tmp_mvar_value_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_19 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 181;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_11 = tmp_mvar_value_19;
        tmp_subscript_name_11 = const_int_pos_34;
        tmp_dict_value_16 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_11, tmp_subscript_name_11, 34 );
        if ( tmp_dict_value_16 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 181;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_69 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_69, tmp_dict_key_16, tmp_dict_value_16 );
        Py_DECREF( tmp_dict_value_16 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_17 = const_str_plain_green;
        tmp_mvar_value_20 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_20 == NULL ))
        {
            tmp_mvar_value_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_20 == NULL )
        {
            Py_DECREF( tmp_assign_source_69 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 182;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_12 = tmp_mvar_value_20;
        tmp_subscript_name_12 = const_int_pos_35;
        tmp_dict_value_17 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_12, tmp_subscript_name_12, 35 );
        if ( tmp_dict_value_17 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_69 );

            exception_lineno = 182;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_69, tmp_dict_key_17, tmp_dict_value_17 );
        Py_DECREF( tmp_dict_value_17 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_18 = const_str_plain_blue;
        tmp_mvar_value_21 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_21 == NULL ))
        {
            tmp_mvar_value_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_21 == NULL )
        {
            Py_DECREF( tmp_assign_source_69 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 183;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_13 = tmp_mvar_value_21;
        tmp_subscript_name_13 = const_int_pos_36;
        tmp_dict_value_18 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_13, tmp_subscript_name_13, 36 );
        if ( tmp_dict_value_18 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_69 );

            exception_lineno = 183;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_69, tmp_dict_key_18, tmp_dict_value_18 );
        Py_DECREF( tmp_dict_value_18 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__afmhot_data, tmp_assign_source_69 );
    }
    {
        PyObject *tmp_assign_source_70;
        PyObject *tmp_dict_key_19;
        PyObject *tmp_dict_value_19;
        PyObject *tmp_subscribed_name_14;
        PyObject *tmp_mvar_value_22;
        PyObject *tmp_subscript_name_14;
        PyObject *tmp_dict_key_20;
        PyObject *tmp_dict_value_20;
        PyObject *tmp_subscribed_name_15;
        PyObject *tmp_mvar_value_23;
        PyObject *tmp_subscript_name_15;
        PyObject *tmp_dict_key_21;
        PyObject *tmp_dict_value_21;
        PyObject *tmp_subscribed_name_16;
        PyObject *tmp_mvar_value_24;
        PyObject *tmp_subscript_name_16;
        tmp_dict_key_19 = const_str_plain_red;
        tmp_mvar_value_22 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_22 == NULL ))
        {
            tmp_mvar_value_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_22 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 187;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_14 = tmp_mvar_value_22;
        tmp_subscript_name_14 = const_int_pos_33;
        tmp_dict_value_19 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_14, tmp_subscript_name_14, 33 );
        if ( tmp_dict_value_19 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 187;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_70 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_70, tmp_dict_key_19, tmp_dict_value_19 );
        Py_DECREF( tmp_dict_value_19 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_20 = const_str_plain_green;
        tmp_mvar_value_23 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_23 == NULL ))
        {
            tmp_mvar_value_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_23 == NULL )
        {
            Py_DECREF( tmp_assign_source_70 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 188;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_15 = tmp_mvar_value_23;
        tmp_subscript_name_15 = const_int_pos_13;
        tmp_dict_value_20 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_15, tmp_subscript_name_15, 13 );
        if ( tmp_dict_value_20 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_70 );

            exception_lineno = 188;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_70, tmp_dict_key_20, tmp_dict_value_20 );
        Py_DECREF( tmp_dict_value_20 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_21 = const_str_plain_blue;
        tmp_mvar_value_24 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_24 == NULL ))
        {
            tmp_mvar_value_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_24 == NULL )
        {
            Py_DECREF( tmp_assign_source_70 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 189;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_16 = tmp_mvar_value_24;
        tmp_subscript_name_16 = const_int_pos_10;
        tmp_dict_value_21 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_16, tmp_subscript_name_16, 10 );
        if ( tmp_dict_value_21 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_70 );

            exception_lineno = 189;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_70, tmp_dict_key_21, tmp_dict_value_21 );
        Py_DECREF( tmp_dict_value_21 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__rainbow_data, tmp_assign_source_70 );
    }
    {
        PyObject *tmp_assign_source_71;
        tmp_assign_source_71 = const_tuple_77bd0eb31ef97c2e7618000ce303f673_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__seismic_data, tmp_assign_source_71 );
    }
    {
        PyObject *tmp_assign_source_72;
        tmp_assign_source_72 = const_tuple_6e6f4e9a37231f81f1e456047fd8c742_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__terrain_data, tmp_assign_source_72 );
    }
    {
        PyObject *tmp_assign_source_73;
        tmp_assign_source_73 = PyDict_Copy( const_dict_79ecbf763b054a3ad895cae3fb89c58e );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gray_data, tmp_assign_source_73 );
    }
    {
        PyObject *tmp_assign_source_74;
        tmp_assign_source_74 = PyDict_Copy( const_dict_d876a613e78a88b4cea47cbcba7077b2 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__hot_data, tmp_assign_source_74 );
    }
    {
        PyObject *tmp_assign_source_75;
        tmp_assign_source_75 = PyDict_Copy( const_dict_a065b631920800bd13e7ea9419838858 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__hsv_data, tmp_assign_source_75 );
    }
    {
        PyObject *tmp_assign_source_76;
        tmp_assign_source_76 = PyDict_Copy( const_dict_fd4a49377d1d658f7d30b821b6352628 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__jet_data, tmp_assign_source_76 );
    }
    {
        PyObject *tmp_assign_source_77;
        tmp_assign_source_77 = PyDict_Copy( const_dict_1b20bf7e6394a197db2b925f2ae9f1f2 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__pink_data, tmp_assign_source_77 );
    }
    {
        PyObject *tmp_assign_source_78;
        tmp_assign_source_78 = PyDict_Copy( const_dict_d6323100fc0b68b2862861068aa9dfb4 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__spring_data, tmp_assign_source_78 );
    }
    {
        PyObject *tmp_assign_source_79;
        tmp_assign_source_79 = PyDict_Copy( const_dict_a6becc14d04a47becd62ae70b4c4482c );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__summer_data, tmp_assign_source_79 );
    }
    {
        PyObject *tmp_assign_source_80;
        tmp_assign_source_80 = PyDict_Copy( const_dict_61b96e51e18659e8ba92a9cb886c68eb );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__winter_data, tmp_assign_source_80 );
    }
    {
        PyObject *tmp_assign_source_81;
        tmp_assign_source_81 = DEEP_COPY( const_dict_e5f8cd4b8b884f01b9dbdb6c0cf95972 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__nipy_spectral_data, tmp_assign_source_81 );
    }
    {
        PyObject *tmp_assign_source_82;
        tmp_assign_source_82 = const_tuple_7eb55817b097308a4aa82a88a7a374a0_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Blues_data, tmp_assign_source_82 );
    }
    {
        PyObject *tmp_assign_source_83;
        tmp_assign_source_83 = const_tuple_a1c2e0d0fdb72592d26c53db2b423104_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__BrBG_data, tmp_assign_source_83 );
    }
    {
        PyObject *tmp_assign_source_84;
        tmp_assign_source_84 = const_tuple_13493111d1a4f8c8a058ebd7f95c09b1_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__BuGn_data, tmp_assign_source_84 );
    }
    {
        PyObject *tmp_assign_source_85;
        tmp_assign_source_85 = const_tuple_3f501f1fed43a18bc40d5702c0cd69db_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__BuPu_data, tmp_assign_source_85 );
    }
    {
        PyObject *tmp_assign_source_86;
        tmp_assign_source_86 = const_tuple_6eb90b29c730cddab6ab1d936156a49c_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__GnBu_data, tmp_assign_source_86 );
    }
    {
        PyObject *tmp_assign_source_87;
        tmp_assign_source_87 = const_tuple_4d8a3db908fea5ac787eae57a231d107_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Greens_data, tmp_assign_source_87 );
    }
    {
        PyObject *tmp_assign_source_88;
        tmp_assign_source_88 = const_tuple_dbd02ca2a43f79960ecaa20263657c10_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Greys_data, tmp_assign_source_88 );
    }
    {
        PyObject *tmp_assign_source_89;
        tmp_assign_source_89 = const_tuple_9e6a97cefbfc93e4dbd6fe4790754edf_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Oranges_data, tmp_assign_source_89 );
    }
    {
        PyObject *tmp_assign_source_90;
        tmp_assign_source_90 = const_tuple_cc9102d236a92569966c4ebd4c8fbcf5_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__OrRd_data, tmp_assign_source_90 );
    }
    {
        PyObject *tmp_assign_source_91;
        tmp_assign_source_91 = const_tuple_e22ad1a6fd2b90375e84cff21f64303a_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PiYG_data, tmp_assign_source_91 );
    }
    {
        PyObject *tmp_assign_source_92;
        tmp_assign_source_92 = const_tuple_2a4c4f5b12a7944706ab0b855d978f15_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PRGn_data, tmp_assign_source_92 );
    }
    {
        PyObject *tmp_assign_source_93;
        tmp_assign_source_93 = const_tuple_4f66db73ea9fdbfdceb9e620df1e4919_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuBu_data, tmp_assign_source_93 );
    }
    {
        PyObject *tmp_assign_source_94;
        tmp_assign_source_94 = const_tuple_122f654ebd563953484696204c943f8b_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuBuGn_data, tmp_assign_source_94 );
    }
    {
        PyObject *tmp_assign_source_95;
        tmp_assign_source_95 = const_tuple_fb0dd03a0e957d10a507ea76b9c3ad27_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuOr_data, tmp_assign_source_95 );
    }
    {
        PyObject *tmp_assign_source_96;
        tmp_assign_source_96 = const_tuple_16581877f4601a2ddb7154cb6281285a_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuRd_data, tmp_assign_source_96 );
    }
    {
        PyObject *tmp_assign_source_97;
        tmp_assign_source_97 = const_tuple_b19a69e04a28b726d8b7d59807ef8eef_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Purples_data, tmp_assign_source_97 );
    }
    {
        PyObject *tmp_assign_source_98;
        tmp_assign_source_98 = const_tuple_d0062c44ff73c1c48f3f7d27f6672421_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdBu_data, tmp_assign_source_98 );
    }
    {
        PyObject *tmp_assign_source_99;
        tmp_assign_source_99 = const_tuple_9b04358fc83d8c29f6d13e55a485e086_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdGy_data, tmp_assign_source_99 );
    }
    {
        PyObject *tmp_assign_source_100;
        tmp_assign_source_100 = const_tuple_1cf08670e58213d33381f121283ddef7_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdPu_data, tmp_assign_source_100 );
    }
    {
        PyObject *tmp_assign_source_101;
        tmp_assign_source_101 = const_tuple_20bd1f5c0a0f9a93d11e666cd7289af4_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdYlBu_data, tmp_assign_source_101 );
    }
    {
        PyObject *tmp_assign_source_102;
        tmp_assign_source_102 = const_tuple_440d7807917857d4ae4d4cd0c76093e7_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdYlGn_data, tmp_assign_source_102 );
    }
    {
        PyObject *tmp_assign_source_103;
        tmp_assign_source_103 = const_tuple_194951aabc8c4d0f914fa1c18e921dac_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Reds_data, tmp_assign_source_103 );
    }
    {
        PyObject *tmp_assign_source_104;
        tmp_assign_source_104 = const_tuple_db9a981db24a26ea90b278665de2841d_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Spectral_data, tmp_assign_source_104 );
    }
    {
        PyObject *tmp_assign_source_105;
        tmp_assign_source_105 = const_tuple_db58afb74f702702860a0cdf1356a649_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlGn_data, tmp_assign_source_105 );
    }
    {
        PyObject *tmp_assign_source_106;
        tmp_assign_source_106 = const_tuple_259735cef93a8d5cd32533f90f8ce8d3_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlGnBu_data, tmp_assign_source_106 );
    }
    {
        PyObject *tmp_assign_source_107;
        tmp_assign_source_107 = const_tuple_ac83b7f87b65db8bc61c88a0c684aae6_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlOrBr_data, tmp_assign_source_107 );
    }
    {
        PyObject *tmp_assign_source_108;
        tmp_assign_source_108 = const_tuple_8a21be97bcec74887e2b70da615f70d9_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlOrRd_data, tmp_assign_source_108 );
    }
    {
        PyObject *tmp_assign_source_109;
        tmp_assign_source_109 = const_tuple_dd7b62811603d0af86732a1f25835a50_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Accent_data, tmp_assign_source_109 );
    }
    {
        PyObject *tmp_assign_source_110;
        tmp_assign_source_110 = const_tuple_6430e1188db9556163de382028b9d704_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Dark2_data, tmp_assign_source_110 );
    }
    {
        PyObject *tmp_assign_source_111;
        tmp_assign_source_111 = const_tuple_b84fc382b1c73eb24052e00184983189_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Paired_data, tmp_assign_source_111 );
    }
    {
        PyObject *tmp_assign_source_112;
        tmp_assign_source_112 = const_tuple_eb5d9c64a7345357330502cba765a133_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Pastel1_data, tmp_assign_source_112 );
    }
    {
        PyObject *tmp_assign_source_113;
        tmp_assign_source_113 = const_tuple_d6bde7eec8df9cf0ee10c9abbaa88fc9_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Pastel2_data, tmp_assign_source_113 );
    }
    {
        PyObject *tmp_assign_source_114;
        tmp_assign_source_114 = const_tuple_de81471e775d0db13ccc93277369c0bb_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Set1_data, tmp_assign_source_114 );
    }
    {
        PyObject *tmp_assign_source_115;
        tmp_assign_source_115 = const_tuple_9fa91c64747bb6ff4492053856cc06e7_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Set2_data, tmp_assign_source_115 );
    }
    {
        PyObject *tmp_assign_source_116;
        tmp_assign_source_116 = const_tuple_2fe5f075a061fd18cc310f1b06eb16ae_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Set3_data, tmp_assign_source_116 );
    }
    {
        PyObject *tmp_assign_source_117;
        tmp_assign_source_117 = PyDict_Copy( const_dict_7ba6c40e971dab085fcf28da729f7167 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_earth_data, tmp_assign_source_117 );
    }
    {
        PyObject *tmp_assign_source_118;
        PyObject *tmp_dict_key_22;
        PyObject *tmp_dict_value_22;
        PyObject *tmp_subscribed_name_17;
        PyObject *tmp_mvar_value_25;
        PyObject *tmp_subscript_name_17;
        PyObject *tmp_dict_key_23;
        PyObject *tmp_dict_value_23;
        PyObject *tmp_subscribed_name_18;
        PyObject *tmp_mvar_value_26;
        PyObject *tmp_subscript_name_18;
        PyObject *tmp_dict_key_24;
        PyObject *tmp_dict_value_24;
        PyObject *tmp_subscribed_name_19;
        PyObject *tmp_mvar_value_27;
        PyObject *tmp_subscript_name_19;
        tmp_dict_key_22 = const_str_plain_red;
        tmp_mvar_value_25 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_25 == NULL ))
        {
            tmp_mvar_value_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_25 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1002;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_17 = tmp_mvar_value_25;
        tmp_subscript_name_17 = const_int_pos_3;
        tmp_dict_value_22 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_17, tmp_subscript_name_17, 3 );
        if ( tmp_dict_value_22 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


            exception_lineno = 1002;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_118 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_118, tmp_dict_key_22, tmp_dict_value_22 );
        Py_DECREF( tmp_dict_value_22 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_23 = const_str_plain_green;
        tmp_mvar_value_26 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_26 == NULL ))
        {
            tmp_mvar_value_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_26 == NULL )
        {
            Py_DECREF( tmp_assign_source_118 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1003;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_18 = tmp_mvar_value_26;
        tmp_subscript_name_18 = const_int_pos_3;
        tmp_dict_value_23 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_18, tmp_subscript_name_18, 3 );
        if ( tmp_dict_value_23 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_118 );

            exception_lineno = 1003;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_118, tmp_dict_key_23, tmp_dict_value_23 );
        Py_DECREF( tmp_dict_value_23 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_24 = const_str_plain_blue;
        tmp_mvar_value_27 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_gfunc );

        if (unlikely( tmp_mvar_value_27 == NULL ))
        {
            tmp_mvar_value_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_gfunc );
        }

        if ( tmp_mvar_value_27 == NULL )
        {
            Py_DECREF( tmp_assign_source_118 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "gfunc" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1004;

            goto frame_exception_exit_1;
        }

        tmp_subscribed_name_19 = tmp_mvar_value_27;
        tmp_subscript_name_19 = const_int_pos_3;
        tmp_dict_value_24 = LOOKUP_SUBSCRIPT_CONST( tmp_subscribed_name_19, tmp_subscript_name_19, 3 );
        if ( tmp_dict_value_24 == NULL )
        {
            assert( ERROR_OCCURRED() );

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            Py_DECREF( tmp_assign_source_118 );

            exception_lineno = 1004;

            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem( tmp_assign_source_118, tmp_dict_key_24, tmp_dict_value_24 );
        Py_DECREF( tmp_dict_value_24 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_gray_data, tmp_assign_source_118 );
    }
    {
        PyObject *tmp_assign_source_119;
        tmp_assign_source_119 = MAKE_FUNCTION_matplotlib$_cm$$$function_46__gist_heat_red(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_red, tmp_assign_source_119 );
    }
    {
        PyObject *tmp_assign_source_120;
        tmp_assign_source_120 = MAKE_FUNCTION_matplotlib$_cm$$$function_47__gist_heat_green(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_green, tmp_assign_source_120 );
    }
    {
        PyObject *tmp_assign_source_121;
        tmp_assign_source_121 = MAKE_FUNCTION_matplotlib$_cm$$$function_48__gist_heat_blue(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_blue, tmp_assign_source_121 );
    }
    {
        PyObject *tmp_assign_source_122;
        PyObject *tmp_dict_key_25;
        PyObject *tmp_dict_value_25;
        PyObject *tmp_mvar_value_28;
        PyObject *tmp_dict_key_26;
        PyObject *tmp_dict_value_26;
        PyObject *tmp_mvar_value_29;
        PyObject *tmp_dict_key_27;
        PyObject *tmp_dict_value_27;
        PyObject *tmp_mvar_value_30;
        tmp_dict_key_25 = const_str_plain_red;
        tmp_mvar_value_28 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_red );

        if (unlikely( tmp_mvar_value_28 == NULL ))
        {
            tmp_mvar_value_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_heat_red );
        }

        CHECK_OBJECT( tmp_mvar_value_28 );
        tmp_dict_value_25 = tmp_mvar_value_28;
        tmp_assign_source_122 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_25, tmp_dict_value_25 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_26 = const_str_plain_green;
        tmp_mvar_value_29 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_green );

        if (unlikely( tmp_mvar_value_29 == NULL ))
        {
            tmp_mvar_value_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_heat_green );
        }

        CHECK_OBJECT( tmp_mvar_value_29 );
        tmp_dict_value_26 = tmp_mvar_value_29;
        tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_26, tmp_dict_value_26 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_27 = const_str_plain_blue;
        tmp_mvar_value_30 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_blue );

        if (unlikely( tmp_mvar_value_30 == NULL ))
        {
            tmp_mvar_value_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_heat_blue );
        }

        CHECK_OBJECT( tmp_mvar_value_30 );
        tmp_dict_value_27 = tmp_mvar_value_30;
        tmp_res = PyDict_SetItem( tmp_assign_source_122, tmp_dict_key_27, tmp_dict_value_27 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_data, tmp_assign_source_122 );
    }
    {
        PyObject *tmp_assign_source_123;
        tmp_assign_source_123 = PyDict_Copy( const_dict_cc81f270cbb7633b5af45d15d4c591ec );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_ncar_data, tmp_assign_source_123 );
    }
    {
        PyObject *tmp_assign_source_124;
        tmp_assign_source_124 = const_tuple_d09dc699a96e56cc6c61b2a9d13ae443_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_rainbow_data, tmp_assign_source_124 );
    }
    {
        PyObject *tmp_assign_source_125;
        tmp_assign_source_125 = PyDict_Copy( const_dict_26510cda7d1dc75818c57eac9563d1d1 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_stern_data, tmp_assign_source_125 );
    }
    {
        PyObject *tmp_assign_source_126;
        tmp_assign_source_126 = MAKE_FUNCTION_matplotlib$_cm$$$function_49__gist_yarg(  );



        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_yarg, tmp_assign_source_126 );
    }
    {
        PyObject *tmp_assign_source_127;
        PyObject *tmp_dict_key_28;
        PyObject *tmp_dict_value_28;
        PyObject *tmp_mvar_value_31;
        PyObject *tmp_dict_key_29;
        PyObject *tmp_dict_value_29;
        PyObject *tmp_mvar_value_32;
        PyObject *tmp_dict_key_30;
        PyObject *tmp_dict_value_30;
        PyObject *tmp_mvar_value_33;
        tmp_dict_key_28 = const_str_plain_red;
        tmp_mvar_value_31 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_yarg );

        if (unlikely( tmp_mvar_value_31 == NULL ))
        {
            tmp_mvar_value_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_yarg );
        }

        CHECK_OBJECT( tmp_mvar_value_31 );
        tmp_dict_value_28 = tmp_mvar_value_31;
        tmp_assign_source_127 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem( tmp_assign_source_127, tmp_dict_key_28, tmp_dict_value_28 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_29 = const_str_plain_green;
        tmp_mvar_value_32 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_yarg );

        if (unlikely( tmp_mvar_value_32 == NULL ))
        {
            tmp_mvar_value_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_yarg );
        }

        CHECK_OBJECT( tmp_mvar_value_32 );
        tmp_dict_value_29 = tmp_mvar_value_32;
        tmp_res = PyDict_SetItem( tmp_assign_source_127, tmp_dict_key_29, tmp_dict_value_29 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_30 = const_str_plain_blue;
        tmp_mvar_value_33 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_yarg );

        if (unlikely( tmp_mvar_value_33 == NULL ))
        {
            tmp_mvar_value_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_yarg );
        }

        CHECK_OBJECT( tmp_mvar_value_33 );
        tmp_dict_value_30 = tmp_mvar_value_33;
        tmp_res = PyDict_SetItem( tmp_assign_source_127, tmp_dict_key_30, tmp_dict_value_30 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_yarg_data, tmp_assign_source_127 );
    }
    {
        PyObject *tmp_assign_source_128;
        tmp_assign_source_128 = DEEP_COPY( const_dict_ac09b61043b30f22f2e956405ad79658 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__coolwarm_data, tmp_assign_source_128 );
    }
    {
        PyObject *tmp_assign_source_129;
        tmp_assign_source_129 = PyDict_Copy( const_dict_46fdda9c2313b830d68498039918be48 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__CMRmap_data, tmp_assign_source_129 );
    }
    {
        PyObject *tmp_assign_source_130;
        tmp_assign_source_130 = DEEP_COPY( const_dict_13dcc09e8b14458a914dc22a80eeee13 );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__wistia_data, tmp_assign_source_130 );
    }
    {
        PyObject *tmp_assign_source_131;
        tmp_assign_source_131 = const_tuple_58dec871a15dc46004a9c29f566fd8e9_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab10_data, tmp_assign_source_131 );
    }
    {
        PyObject *tmp_assign_source_132;
        tmp_assign_source_132 = const_tuple_391173ce944bd5a033152d725addac81_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab20_data, tmp_assign_source_132 );
    }
    {
        PyObject *tmp_assign_source_133;
        tmp_assign_source_133 = const_tuple_53dc862f8960bed320d0251ce04aeaf0_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab20b_data, tmp_assign_source_133 );
    }
    {
        PyObject *tmp_assign_source_134;
        tmp_assign_source_134 = const_tuple_ef7272d3c529510edf3b0815822dbaa3_tuple;
        UPDATE_STRING_DICT0( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab20c_data, tmp_assign_source_134 );
    }
    {
        PyObject *tmp_assign_source_135;
        PyObject *tmp_dict_key_31;
        PyObject *tmp_dict_value_31;
        PyObject *tmp_mvar_value_34;
        PyObject *tmp_dict_key_32;
        PyObject *tmp_dict_value_32;
        PyObject *tmp_mvar_value_35;
        PyObject *tmp_dict_key_33;
        PyObject *tmp_dict_value_33;
        PyObject *tmp_mvar_value_36;
        PyObject *tmp_dict_key_34;
        PyObject *tmp_dict_value_34;
        PyObject *tmp_mvar_value_37;
        PyObject *tmp_dict_key_35;
        PyObject *tmp_dict_value_35;
        PyObject *tmp_mvar_value_38;
        PyObject *tmp_dict_key_36;
        PyObject *tmp_dict_value_36;
        PyObject *tmp_mvar_value_39;
        PyObject *tmp_dict_key_37;
        PyObject *tmp_dict_value_37;
        PyObject *tmp_mvar_value_40;
        PyObject *tmp_dict_key_38;
        PyObject *tmp_dict_value_38;
        PyObject *tmp_mvar_value_41;
        PyObject *tmp_dict_key_39;
        PyObject *tmp_dict_value_39;
        PyObject *tmp_mvar_value_42;
        PyObject *tmp_dict_key_40;
        PyObject *tmp_dict_value_40;
        PyObject *tmp_mvar_value_43;
        PyObject *tmp_dict_key_41;
        PyObject *tmp_dict_value_41;
        PyObject *tmp_mvar_value_44;
        PyObject *tmp_dict_key_42;
        PyObject *tmp_dict_value_42;
        PyObject *tmp_mvar_value_45;
        PyObject *tmp_dict_key_43;
        PyObject *tmp_dict_value_43;
        PyObject *tmp_mvar_value_46;
        PyObject *tmp_dict_key_44;
        PyObject *tmp_dict_value_44;
        PyObject *tmp_mvar_value_47;
        PyObject *tmp_dict_key_45;
        PyObject *tmp_dict_value_45;
        PyObject *tmp_mvar_value_48;
        PyObject *tmp_dict_key_46;
        PyObject *tmp_dict_value_46;
        PyObject *tmp_mvar_value_49;
        PyObject *tmp_dict_key_47;
        PyObject *tmp_dict_value_47;
        PyObject *tmp_mvar_value_50;
        PyObject *tmp_dict_key_48;
        PyObject *tmp_dict_value_48;
        PyObject *tmp_mvar_value_51;
        PyObject *tmp_dict_key_49;
        PyObject *tmp_dict_value_49;
        PyObject *tmp_mvar_value_52;
        PyObject *tmp_dict_key_50;
        PyObject *tmp_dict_value_50;
        PyObject *tmp_mvar_value_53;
        PyObject *tmp_dict_key_51;
        PyObject *tmp_dict_value_51;
        PyObject *tmp_mvar_value_54;
        PyObject *tmp_dict_key_52;
        PyObject *tmp_dict_value_52;
        PyObject *tmp_mvar_value_55;
        PyObject *tmp_dict_key_53;
        PyObject *tmp_dict_value_53;
        PyObject *tmp_mvar_value_56;
        PyObject *tmp_dict_key_54;
        PyObject *tmp_dict_value_54;
        PyObject *tmp_mvar_value_57;
        PyObject *tmp_dict_key_55;
        PyObject *tmp_dict_value_55;
        PyObject *tmp_mvar_value_58;
        PyObject *tmp_dict_key_56;
        PyObject *tmp_dict_value_56;
        PyObject *tmp_mvar_value_59;
        PyObject *tmp_dict_key_57;
        PyObject *tmp_dict_value_57;
        PyObject *tmp_mvar_value_60;
        PyObject *tmp_dict_key_58;
        PyObject *tmp_dict_value_58;
        PyObject *tmp_mvar_value_61;
        PyObject *tmp_dict_key_59;
        PyObject *tmp_dict_value_59;
        PyObject *tmp_mvar_value_62;
        PyObject *tmp_dict_key_60;
        PyObject *tmp_dict_value_60;
        PyObject *tmp_mvar_value_63;
        PyObject *tmp_dict_key_61;
        PyObject *tmp_dict_value_61;
        PyObject *tmp_mvar_value_64;
        PyObject *tmp_dict_key_62;
        PyObject *tmp_dict_value_62;
        PyObject *tmp_mvar_value_65;
        PyObject *tmp_dict_key_63;
        PyObject *tmp_dict_value_63;
        PyObject *tmp_mvar_value_66;
        PyObject *tmp_dict_key_64;
        PyObject *tmp_dict_value_64;
        PyObject *tmp_mvar_value_67;
        PyObject *tmp_dict_key_65;
        PyObject *tmp_dict_value_65;
        PyObject *tmp_mvar_value_68;
        PyObject *tmp_dict_key_66;
        PyObject *tmp_dict_value_66;
        PyObject *tmp_mvar_value_69;
        PyObject *tmp_dict_key_67;
        PyObject *tmp_dict_value_67;
        PyObject *tmp_mvar_value_70;
        PyObject *tmp_dict_key_68;
        PyObject *tmp_dict_value_68;
        PyObject *tmp_mvar_value_71;
        PyObject *tmp_dict_key_69;
        PyObject *tmp_dict_value_69;
        PyObject *tmp_mvar_value_72;
        PyObject *tmp_dict_key_70;
        PyObject *tmp_dict_value_70;
        PyObject *tmp_mvar_value_73;
        PyObject *tmp_dict_key_71;
        PyObject *tmp_dict_value_71;
        PyObject *tmp_mvar_value_74;
        PyObject *tmp_dict_key_72;
        PyObject *tmp_dict_value_72;
        PyObject *tmp_mvar_value_75;
        PyObject *tmp_dict_key_73;
        PyObject *tmp_dict_value_73;
        PyObject *tmp_mvar_value_76;
        PyObject *tmp_dict_key_74;
        PyObject *tmp_dict_value_74;
        PyObject *tmp_mvar_value_77;
        PyObject *tmp_dict_key_75;
        PyObject *tmp_dict_value_75;
        PyObject *tmp_mvar_value_78;
        PyObject *tmp_dict_key_76;
        PyObject *tmp_dict_value_76;
        PyObject *tmp_mvar_value_79;
        PyObject *tmp_dict_key_77;
        PyObject *tmp_dict_value_77;
        PyObject *tmp_mvar_value_80;
        PyObject *tmp_dict_key_78;
        PyObject *tmp_dict_value_78;
        PyObject *tmp_mvar_value_81;
        PyObject *tmp_dict_key_79;
        PyObject *tmp_dict_value_79;
        PyObject *tmp_mvar_value_82;
        PyObject *tmp_dict_key_80;
        PyObject *tmp_dict_value_80;
        PyObject *tmp_mvar_value_83;
        PyObject *tmp_dict_key_81;
        PyObject *tmp_dict_value_81;
        PyObject *tmp_mvar_value_84;
        PyObject *tmp_dict_key_82;
        PyObject *tmp_dict_value_82;
        PyObject *tmp_mvar_value_85;
        PyObject *tmp_dict_key_83;
        PyObject *tmp_dict_value_83;
        PyObject *tmp_mvar_value_86;
        PyObject *tmp_dict_key_84;
        PyObject *tmp_dict_value_84;
        PyObject *tmp_mvar_value_87;
        PyObject *tmp_dict_key_85;
        PyObject *tmp_dict_value_85;
        PyObject *tmp_mvar_value_88;
        PyObject *tmp_dict_key_86;
        PyObject *tmp_dict_value_86;
        PyObject *tmp_mvar_value_89;
        PyObject *tmp_dict_key_87;
        PyObject *tmp_dict_value_87;
        PyObject *tmp_mvar_value_90;
        PyObject *tmp_dict_key_88;
        PyObject *tmp_dict_value_88;
        PyObject *tmp_mvar_value_91;
        PyObject *tmp_dict_key_89;
        PyObject *tmp_dict_value_89;
        PyObject *tmp_mvar_value_92;
        PyObject *tmp_dict_key_90;
        PyObject *tmp_dict_value_90;
        PyObject *tmp_mvar_value_93;
        PyObject *tmp_dict_key_91;
        PyObject *tmp_dict_value_91;
        PyObject *tmp_mvar_value_94;
        PyObject *tmp_dict_key_92;
        PyObject *tmp_dict_value_92;
        PyObject *tmp_mvar_value_95;
        PyObject *tmp_dict_key_93;
        PyObject *tmp_dict_value_93;
        PyObject *tmp_mvar_value_96;
        PyObject *tmp_dict_key_94;
        PyObject *tmp_dict_value_94;
        PyObject *tmp_dict_key_95;
        PyObject *tmp_dict_value_95;
        PyObject *tmp_mvar_value_97;
        PyObject *tmp_dict_key_96;
        PyObject *tmp_dict_value_96;
        PyObject *tmp_dict_key_97;
        PyObject *tmp_dict_value_97;
        PyObject *tmp_mvar_value_98;
        PyObject *tmp_dict_key_98;
        PyObject *tmp_dict_value_98;
        PyObject *tmp_dict_key_99;
        PyObject *tmp_dict_value_99;
        PyObject *tmp_mvar_value_99;
        PyObject *tmp_dict_key_100;
        PyObject *tmp_dict_value_100;
        PyObject *tmp_dict_key_101;
        PyObject *tmp_dict_value_101;
        PyObject *tmp_mvar_value_100;
        PyObject *tmp_dict_key_102;
        PyObject *tmp_dict_value_102;
        PyObject *tmp_dict_key_103;
        PyObject *tmp_dict_value_103;
        PyObject *tmp_mvar_value_101;
        PyObject *tmp_dict_key_104;
        PyObject *tmp_dict_value_104;
        PyObject *tmp_dict_key_105;
        PyObject *tmp_dict_value_105;
        PyObject *tmp_mvar_value_102;
        PyObject *tmp_dict_key_106;
        PyObject *tmp_dict_value_106;
        PyObject *tmp_dict_key_107;
        PyObject *tmp_dict_value_107;
        PyObject *tmp_mvar_value_103;
        PyObject *tmp_dict_key_108;
        PyObject *tmp_dict_value_108;
        PyObject *tmp_dict_key_109;
        PyObject *tmp_dict_value_109;
        PyObject *tmp_mvar_value_104;
        PyObject *tmp_dict_key_110;
        PyObject *tmp_dict_value_110;
        PyObject *tmp_dict_key_111;
        PyObject *tmp_dict_value_111;
        PyObject *tmp_mvar_value_105;
        PyObject *tmp_dict_key_112;
        PyObject *tmp_dict_value_112;
        PyObject *tmp_dict_key_113;
        PyObject *tmp_dict_value_113;
        PyObject *tmp_mvar_value_106;
        PyObject *tmp_dict_key_114;
        PyObject *tmp_dict_value_114;
        PyObject *tmp_dict_key_115;
        PyObject *tmp_dict_value_115;
        PyObject *tmp_mvar_value_107;
        PyObject *tmp_dict_key_116;
        PyObject *tmp_dict_value_116;
        PyObject *tmp_dict_key_117;
        PyObject *tmp_dict_value_117;
        PyObject *tmp_mvar_value_108;
        tmp_dict_key_31 = const_str_plain_Blues;
        tmp_mvar_value_34 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Blues_data );

        if (unlikely( tmp_mvar_value_34 == NULL ))
        {
            tmp_mvar_value_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Blues_data );
        }

        if ( tmp_mvar_value_34 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Blues_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1350;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_31 = tmp_mvar_value_34;
        tmp_assign_source_135 = _PyDict_NewPresized( 75 );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_31, tmp_dict_value_31 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_32 = const_str_plain_BrBG;
        tmp_mvar_value_35 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__BrBG_data );

        if (unlikely( tmp_mvar_value_35 == NULL ))
        {
            tmp_mvar_value_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BrBG_data );
        }

        if ( tmp_mvar_value_35 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_BrBG_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1351;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_32 = tmp_mvar_value_35;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_32, tmp_dict_value_32 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_33 = const_str_plain_BuGn;
        tmp_mvar_value_36 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__BuGn_data );

        if (unlikely( tmp_mvar_value_36 == NULL ))
        {
            tmp_mvar_value_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BuGn_data );
        }

        if ( tmp_mvar_value_36 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_BuGn_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1352;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_33 = tmp_mvar_value_36;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_33, tmp_dict_value_33 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_34 = const_str_plain_BuPu;
        tmp_mvar_value_37 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__BuPu_data );

        if (unlikely( tmp_mvar_value_37 == NULL ))
        {
            tmp_mvar_value_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__BuPu_data );
        }

        if ( tmp_mvar_value_37 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_BuPu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1353;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_34 = tmp_mvar_value_37;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_34, tmp_dict_value_34 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_35 = const_str_plain_CMRmap;
        tmp_mvar_value_38 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__CMRmap_data );

        if (unlikely( tmp_mvar_value_38 == NULL ))
        {
            tmp_mvar_value_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__CMRmap_data );
        }

        CHECK_OBJECT( tmp_mvar_value_38 );
        tmp_dict_value_35 = tmp_mvar_value_38;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_35, tmp_dict_value_35 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_36 = const_str_plain_GnBu;
        tmp_mvar_value_39 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__GnBu_data );

        if (unlikely( tmp_mvar_value_39 == NULL ))
        {
            tmp_mvar_value_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__GnBu_data );
        }

        if ( tmp_mvar_value_39 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_GnBu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1355;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_36 = tmp_mvar_value_39;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_36, tmp_dict_value_36 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_37 = const_str_plain_Greens;
        tmp_mvar_value_40 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Greens_data );

        if (unlikely( tmp_mvar_value_40 == NULL ))
        {
            tmp_mvar_value_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Greens_data );
        }

        if ( tmp_mvar_value_40 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Greens_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1356;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_37 = tmp_mvar_value_40;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_37, tmp_dict_value_37 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_38 = const_str_plain_Greys;
        tmp_mvar_value_41 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Greys_data );

        if (unlikely( tmp_mvar_value_41 == NULL ))
        {
            tmp_mvar_value_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Greys_data );
        }

        if ( tmp_mvar_value_41 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Greys_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1357;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_38 = tmp_mvar_value_41;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_38, tmp_dict_value_38 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_39 = const_str_plain_OrRd;
        tmp_mvar_value_42 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__OrRd_data );

        if (unlikely( tmp_mvar_value_42 == NULL ))
        {
            tmp_mvar_value_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__OrRd_data );
        }

        if ( tmp_mvar_value_42 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_OrRd_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1358;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_39 = tmp_mvar_value_42;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_39, tmp_dict_value_39 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_40 = const_str_plain_Oranges;
        tmp_mvar_value_43 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Oranges_data );

        if (unlikely( tmp_mvar_value_43 == NULL ))
        {
            tmp_mvar_value_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Oranges_data );
        }

        if ( tmp_mvar_value_43 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Oranges_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1359;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_40 = tmp_mvar_value_43;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_40, tmp_dict_value_40 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_41 = const_str_plain_PRGn;
        tmp_mvar_value_44 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PRGn_data );

        if (unlikely( tmp_mvar_value_44 == NULL ))
        {
            tmp_mvar_value_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PRGn_data );
        }

        if ( tmp_mvar_value_44 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PRGn_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1360;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_41 = tmp_mvar_value_44;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_41, tmp_dict_value_41 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_42 = const_str_plain_PiYG;
        tmp_mvar_value_45 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PiYG_data );

        if (unlikely( tmp_mvar_value_45 == NULL ))
        {
            tmp_mvar_value_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PiYG_data );
        }

        if ( tmp_mvar_value_45 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PiYG_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1361;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_42 = tmp_mvar_value_45;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_42, tmp_dict_value_42 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_43 = const_str_plain_PuBu;
        tmp_mvar_value_46 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuBu_data );

        if (unlikely( tmp_mvar_value_46 == NULL ))
        {
            tmp_mvar_value_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PuBu_data );
        }

        if ( tmp_mvar_value_46 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PuBu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1362;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_43 = tmp_mvar_value_46;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_43, tmp_dict_value_43 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_44 = const_str_plain_PuBuGn;
        tmp_mvar_value_47 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuBuGn_data );

        if (unlikely( tmp_mvar_value_47 == NULL ))
        {
            tmp_mvar_value_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PuBuGn_data );
        }

        if ( tmp_mvar_value_47 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PuBuGn_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1363;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_44 = tmp_mvar_value_47;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_44, tmp_dict_value_44 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_45 = const_str_plain_PuOr;
        tmp_mvar_value_48 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuOr_data );

        if (unlikely( tmp_mvar_value_48 == NULL ))
        {
            tmp_mvar_value_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PuOr_data );
        }

        if ( tmp_mvar_value_48 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PuOr_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1364;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_45 = tmp_mvar_value_48;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_45, tmp_dict_value_45 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_46 = const_str_plain_PuRd;
        tmp_mvar_value_49 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__PuRd_data );

        if (unlikely( tmp_mvar_value_49 == NULL ))
        {
            tmp_mvar_value_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__PuRd_data );
        }

        if ( tmp_mvar_value_49 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_PuRd_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1365;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_46 = tmp_mvar_value_49;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_46, tmp_dict_value_46 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_47 = const_str_plain_Purples;
        tmp_mvar_value_50 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Purples_data );

        if (unlikely( tmp_mvar_value_50 == NULL ))
        {
            tmp_mvar_value_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Purples_data );
        }

        if ( tmp_mvar_value_50 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Purples_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1366;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_47 = tmp_mvar_value_50;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_47, tmp_dict_value_47 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_48 = const_str_plain_RdBu;
        tmp_mvar_value_51 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdBu_data );

        if (unlikely( tmp_mvar_value_51 == NULL ))
        {
            tmp_mvar_value_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RdBu_data );
        }

        if ( tmp_mvar_value_51 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RdBu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1367;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_48 = tmp_mvar_value_51;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_48, tmp_dict_value_48 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_49 = const_str_plain_RdGy;
        tmp_mvar_value_52 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdGy_data );

        if (unlikely( tmp_mvar_value_52 == NULL ))
        {
            tmp_mvar_value_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RdGy_data );
        }

        if ( tmp_mvar_value_52 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RdGy_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1368;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_49 = tmp_mvar_value_52;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_49, tmp_dict_value_49 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_50 = const_str_plain_RdPu;
        tmp_mvar_value_53 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdPu_data );

        if (unlikely( tmp_mvar_value_53 == NULL ))
        {
            tmp_mvar_value_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RdPu_data );
        }

        if ( tmp_mvar_value_53 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RdPu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1369;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_50 = tmp_mvar_value_53;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_50, tmp_dict_value_50 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_51 = const_str_plain_RdYlBu;
        tmp_mvar_value_54 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdYlBu_data );

        if (unlikely( tmp_mvar_value_54 == NULL ))
        {
            tmp_mvar_value_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RdYlBu_data );
        }

        if ( tmp_mvar_value_54 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RdYlBu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1370;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_51 = tmp_mvar_value_54;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_51, tmp_dict_value_51 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_52 = const_str_plain_RdYlGn;
        tmp_mvar_value_55 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__RdYlGn_data );

        if (unlikely( tmp_mvar_value_55 == NULL ))
        {
            tmp_mvar_value_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__RdYlGn_data );
        }

        if ( tmp_mvar_value_55 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_RdYlGn_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1371;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_52 = tmp_mvar_value_55;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_52, tmp_dict_value_52 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_53 = const_str_plain_Reds;
        tmp_mvar_value_56 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Reds_data );

        if (unlikely( tmp_mvar_value_56 == NULL ))
        {
            tmp_mvar_value_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Reds_data );
        }

        if ( tmp_mvar_value_56 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Reds_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1372;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_53 = tmp_mvar_value_56;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_53, tmp_dict_value_53 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_54 = const_str_plain_Spectral;
        tmp_mvar_value_57 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Spectral_data );

        if (unlikely( tmp_mvar_value_57 == NULL ))
        {
            tmp_mvar_value_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Spectral_data );
        }

        if ( tmp_mvar_value_57 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Spectral_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1373;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_54 = tmp_mvar_value_57;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_54, tmp_dict_value_54 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_55 = const_str_plain_Wistia;
        tmp_mvar_value_58 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__wistia_data );

        if (unlikely( tmp_mvar_value_58 == NULL ))
        {
            tmp_mvar_value_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__wistia_data );
        }

        CHECK_OBJECT( tmp_mvar_value_58 );
        tmp_dict_value_55 = tmp_mvar_value_58;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_55, tmp_dict_value_55 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_56 = const_str_plain_YlGn;
        tmp_mvar_value_59 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlGn_data );

        if (unlikely( tmp_mvar_value_59 == NULL ))
        {
            tmp_mvar_value_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__YlGn_data );
        }

        if ( tmp_mvar_value_59 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_YlGn_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1375;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_56 = tmp_mvar_value_59;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_56, tmp_dict_value_56 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_57 = const_str_plain_YlGnBu;
        tmp_mvar_value_60 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlGnBu_data );

        if (unlikely( tmp_mvar_value_60 == NULL ))
        {
            tmp_mvar_value_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__YlGnBu_data );
        }

        if ( tmp_mvar_value_60 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_YlGnBu_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1376;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_57 = tmp_mvar_value_60;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_57, tmp_dict_value_57 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_58 = const_str_plain_YlOrBr;
        tmp_mvar_value_61 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlOrBr_data );

        if (unlikely( tmp_mvar_value_61 == NULL ))
        {
            tmp_mvar_value_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__YlOrBr_data );
        }

        if ( tmp_mvar_value_61 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_YlOrBr_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1377;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_58 = tmp_mvar_value_61;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_58, tmp_dict_value_58 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_59 = const_str_plain_YlOrRd;
        tmp_mvar_value_62 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__YlOrRd_data );

        if (unlikely( tmp_mvar_value_62 == NULL ))
        {
            tmp_mvar_value_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__YlOrRd_data );
        }

        if ( tmp_mvar_value_62 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_YlOrRd_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1378;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_59 = tmp_mvar_value_62;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_59, tmp_dict_value_59 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_60 = const_str_plain_afmhot;
        tmp_mvar_value_63 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__afmhot_data );

        if (unlikely( tmp_mvar_value_63 == NULL ))
        {
            tmp_mvar_value_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__afmhot_data );
        }

        if ( tmp_mvar_value_63 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_afmhot_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1379;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_60 = tmp_mvar_value_63;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_60, tmp_dict_value_60 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_61 = const_str_plain_autumn;
        tmp_mvar_value_64 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__autumn_data );

        if (unlikely( tmp_mvar_value_64 == NULL ))
        {
            tmp_mvar_value_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__autumn_data );
        }

        if ( tmp_mvar_value_64 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_autumn_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1380;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_61 = tmp_mvar_value_64;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_61, tmp_dict_value_61 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_62 = const_str_plain_binary;
        tmp_mvar_value_65 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__binary_data );

        if (unlikely( tmp_mvar_value_65 == NULL ))
        {
            tmp_mvar_value_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__binary_data );
        }

        if ( tmp_mvar_value_65 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_binary_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1381;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_62 = tmp_mvar_value_65;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_62, tmp_dict_value_62 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_63 = const_str_plain_bone;
        tmp_mvar_value_66 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__bone_data );

        if (unlikely( tmp_mvar_value_66 == NULL ))
        {
            tmp_mvar_value_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bone_data );
        }

        if ( tmp_mvar_value_66 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_bone_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1382;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_63 = tmp_mvar_value_66;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_63, tmp_dict_value_63 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_64 = const_str_plain_brg;
        tmp_mvar_value_67 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__brg_data );

        if (unlikely( tmp_mvar_value_67 == NULL ))
        {
            tmp_mvar_value_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__brg_data );
        }

        if ( tmp_mvar_value_67 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_brg_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1383;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_64 = tmp_mvar_value_67;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_64, tmp_dict_value_64 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_65 = const_str_plain_bwr;
        tmp_mvar_value_68 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__bwr_data );

        if (unlikely( tmp_mvar_value_68 == NULL ))
        {
            tmp_mvar_value_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__bwr_data );
        }

        if ( tmp_mvar_value_68 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_bwr_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1384;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_65 = tmp_mvar_value_68;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_65, tmp_dict_value_65 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_66 = const_str_plain_cool;
        tmp_mvar_value_69 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__cool_data );

        if (unlikely( tmp_mvar_value_69 == NULL ))
        {
            tmp_mvar_value_69 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cool_data );
        }

        if ( tmp_mvar_value_69 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_cool_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1385;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_66 = tmp_mvar_value_69;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_66, tmp_dict_value_66 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_67 = const_str_plain_coolwarm;
        tmp_mvar_value_70 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__coolwarm_data );

        if (unlikely( tmp_mvar_value_70 == NULL ))
        {
            tmp_mvar_value_70 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__coolwarm_data );
        }

        CHECK_OBJECT( tmp_mvar_value_70 );
        tmp_dict_value_67 = tmp_mvar_value_70;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_67, tmp_dict_value_67 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_68 = const_str_plain_copper;
        tmp_mvar_value_71 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__copper_data );

        if (unlikely( tmp_mvar_value_71 == NULL ))
        {
            tmp_mvar_value_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__copper_data );
        }

        if ( tmp_mvar_value_71 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_copper_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1387;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_68 = tmp_mvar_value_71;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_68, tmp_dict_value_68 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_69 = const_str_plain_cubehelix;
        tmp_mvar_value_72 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__cubehelix_data );

        if (unlikely( tmp_mvar_value_72 == NULL ))
        {
            tmp_mvar_value_72 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__cubehelix_data );
        }

        if ( tmp_mvar_value_72 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_cubehelix_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1388;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_69 = tmp_mvar_value_72;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_69, tmp_dict_value_69 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_70 = const_str_plain_flag;
        tmp_mvar_value_73 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__flag_data );

        if (unlikely( tmp_mvar_value_73 == NULL ))
        {
            tmp_mvar_value_73 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__flag_data );
        }

        if ( tmp_mvar_value_73 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_flag_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1389;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_70 = tmp_mvar_value_73;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_70, tmp_dict_value_70 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_71 = const_str_plain_gist_earth;
        tmp_mvar_value_74 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_earth_data );

        if (unlikely( tmp_mvar_value_74 == NULL ))
        {
            tmp_mvar_value_74 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_earth_data );
        }

        if ( tmp_mvar_value_74 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_gist_earth_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1390;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_71 = tmp_mvar_value_74;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_71, tmp_dict_value_71 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_72 = const_str_plain_gist_gray;
        tmp_mvar_value_75 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_gray_data );

        if (unlikely( tmp_mvar_value_75 == NULL ))
        {
            tmp_mvar_value_75 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_gray_data );
        }

        CHECK_OBJECT( tmp_mvar_value_75 );
        tmp_dict_value_72 = tmp_mvar_value_75;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_72, tmp_dict_value_72 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_73 = const_str_plain_gist_heat;
        tmp_mvar_value_76 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_heat_data );

        if (unlikely( tmp_mvar_value_76 == NULL ))
        {
            tmp_mvar_value_76 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_heat_data );
        }

        CHECK_OBJECT( tmp_mvar_value_76 );
        tmp_dict_value_73 = tmp_mvar_value_76;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_73, tmp_dict_value_73 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_74 = const_str_plain_gist_ncar;
        tmp_mvar_value_77 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_ncar_data );

        if (unlikely( tmp_mvar_value_77 == NULL ))
        {
            tmp_mvar_value_77 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_ncar_data );
        }

        CHECK_OBJECT( tmp_mvar_value_77 );
        tmp_dict_value_74 = tmp_mvar_value_77;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_74, tmp_dict_value_74 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_75 = const_str_plain_gist_rainbow;
        tmp_mvar_value_78 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_rainbow_data );

        if (unlikely( tmp_mvar_value_78 == NULL ))
        {
            tmp_mvar_value_78 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_rainbow_data );
        }

        CHECK_OBJECT( tmp_mvar_value_78 );
        tmp_dict_value_75 = tmp_mvar_value_78;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_75, tmp_dict_value_75 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_76 = const_str_plain_gist_stern;
        tmp_mvar_value_79 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_stern_data );

        if (unlikely( tmp_mvar_value_79 == NULL ))
        {
            tmp_mvar_value_79 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_stern_data );
        }

        CHECK_OBJECT( tmp_mvar_value_79 );
        tmp_dict_value_76 = tmp_mvar_value_79;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_76, tmp_dict_value_76 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_77 = const_str_plain_gist_yarg;
        tmp_mvar_value_80 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gist_yarg_data );

        if (unlikely( tmp_mvar_value_80 == NULL ))
        {
            tmp_mvar_value_80 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gist_yarg_data );
        }

        CHECK_OBJECT( tmp_mvar_value_80 );
        tmp_dict_value_77 = tmp_mvar_value_80;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_77, tmp_dict_value_77 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_78 = const_str_plain_gnuplot;
        tmp_mvar_value_81 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gnuplot_data );

        if (unlikely( tmp_mvar_value_81 == NULL ))
        {
            tmp_mvar_value_81 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gnuplot_data );
        }

        if ( tmp_mvar_value_81 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_gnuplot_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1397;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_78 = tmp_mvar_value_81;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_78, tmp_dict_value_78 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_79 = const_str_plain_gnuplot2;
        tmp_mvar_value_82 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gnuplot2_data );

        if (unlikely( tmp_mvar_value_82 == NULL ))
        {
            tmp_mvar_value_82 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gnuplot2_data );
        }

        if ( tmp_mvar_value_82 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_gnuplot2_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1398;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_79 = tmp_mvar_value_82;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_79, tmp_dict_value_79 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_80 = const_str_plain_gray;
        tmp_mvar_value_83 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__gray_data );

        if (unlikely( tmp_mvar_value_83 == NULL ))
        {
            tmp_mvar_value_83 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__gray_data );
        }

        if ( tmp_mvar_value_83 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_gray_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1399;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_80 = tmp_mvar_value_83;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_80, tmp_dict_value_80 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_81 = const_str_plain_hot;
        tmp_mvar_value_84 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__hot_data );

        if (unlikely( tmp_mvar_value_84 == NULL ))
        {
            tmp_mvar_value_84 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__hot_data );
        }

        if ( tmp_mvar_value_84 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_hot_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1400;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_81 = tmp_mvar_value_84;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_81, tmp_dict_value_81 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_82 = const_str_plain_hsv;
        tmp_mvar_value_85 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__hsv_data );

        if (unlikely( tmp_mvar_value_85 == NULL ))
        {
            tmp_mvar_value_85 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__hsv_data );
        }

        if ( tmp_mvar_value_85 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_hsv_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1401;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_82 = tmp_mvar_value_85;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_82, tmp_dict_value_82 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_83 = const_str_plain_jet;
        tmp_mvar_value_86 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__jet_data );

        if (unlikely( tmp_mvar_value_86 == NULL ))
        {
            tmp_mvar_value_86 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__jet_data );
        }

        if ( tmp_mvar_value_86 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_jet_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1402;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_83 = tmp_mvar_value_86;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_83, tmp_dict_value_83 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_84 = const_str_plain_nipy_spectral;
        tmp_mvar_value_87 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__nipy_spectral_data );

        if (unlikely( tmp_mvar_value_87 == NULL ))
        {
            tmp_mvar_value_87 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__nipy_spectral_data );
        }

        if ( tmp_mvar_value_87 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_nipy_spectral_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1403;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_84 = tmp_mvar_value_87;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_84, tmp_dict_value_84 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_85 = const_str_plain_ocean;
        tmp_mvar_value_88 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__ocean_data );

        if (unlikely( tmp_mvar_value_88 == NULL ))
        {
            tmp_mvar_value_88 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__ocean_data );
        }

        if ( tmp_mvar_value_88 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_ocean_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1404;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_85 = tmp_mvar_value_88;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_85, tmp_dict_value_85 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_86 = const_str_plain_pink;
        tmp_mvar_value_89 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__pink_data );

        if (unlikely( tmp_mvar_value_89 == NULL ))
        {
            tmp_mvar_value_89 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__pink_data );
        }

        if ( tmp_mvar_value_89 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_pink_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1405;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_86 = tmp_mvar_value_89;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_86, tmp_dict_value_86 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_87 = const_str_plain_prism;
        tmp_mvar_value_90 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__prism_data );

        if (unlikely( tmp_mvar_value_90 == NULL ))
        {
            tmp_mvar_value_90 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__prism_data );
        }

        if ( tmp_mvar_value_90 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_prism_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1406;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_87 = tmp_mvar_value_90;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_87, tmp_dict_value_87 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_88 = const_str_plain_rainbow;
        tmp_mvar_value_91 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__rainbow_data );

        if (unlikely( tmp_mvar_value_91 == NULL ))
        {
            tmp_mvar_value_91 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__rainbow_data );
        }

        if ( tmp_mvar_value_91 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_rainbow_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1407;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_88 = tmp_mvar_value_91;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_88, tmp_dict_value_88 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_89 = const_str_plain_seismic;
        tmp_mvar_value_92 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__seismic_data );

        if (unlikely( tmp_mvar_value_92 == NULL ))
        {
            tmp_mvar_value_92 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__seismic_data );
        }

        if ( tmp_mvar_value_92 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_seismic_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1408;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_89 = tmp_mvar_value_92;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_89, tmp_dict_value_89 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_90 = const_str_plain_spring;
        tmp_mvar_value_93 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__spring_data );

        if (unlikely( tmp_mvar_value_93 == NULL ))
        {
            tmp_mvar_value_93 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__spring_data );
        }

        if ( tmp_mvar_value_93 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_spring_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1409;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_90 = tmp_mvar_value_93;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_90, tmp_dict_value_90 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_91 = const_str_plain_summer;
        tmp_mvar_value_94 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__summer_data );

        if (unlikely( tmp_mvar_value_94 == NULL ))
        {
            tmp_mvar_value_94 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__summer_data );
        }

        if ( tmp_mvar_value_94 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_summer_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1410;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_91 = tmp_mvar_value_94;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_91, tmp_dict_value_91 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_92 = const_str_plain_terrain;
        tmp_mvar_value_95 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__terrain_data );

        if (unlikely( tmp_mvar_value_95 == NULL ))
        {
            tmp_mvar_value_95 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__terrain_data );
        }

        if ( tmp_mvar_value_95 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_terrain_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1411;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_92 = tmp_mvar_value_95;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_92, tmp_dict_value_92 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_93 = const_str_plain_winter;
        tmp_mvar_value_96 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__winter_data );

        if (unlikely( tmp_mvar_value_96 == NULL ))
        {
            tmp_mvar_value_96 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__winter_data );
        }

        if ( tmp_mvar_value_96 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_winter_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1412;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_93 = tmp_mvar_value_96;
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_93, tmp_dict_value_93 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_94 = const_str_plain_Accent;
        tmp_dict_key_95 = const_str_plain_listed;
        tmp_mvar_value_97 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Accent_data );

        if (unlikely( tmp_mvar_value_97 == NULL ))
        {
            tmp_mvar_value_97 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Accent_data );
        }

        if ( tmp_mvar_value_97 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Accent_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1414;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_95 = tmp_mvar_value_97;
        tmp_dict_value_94 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_94, tmp_dict_key_95, tmp_dict_value_95 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_94, tmp_dict_value_94 );
        Py_DECREF( tmp_dict_value_94 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_96 = const_str_plain_Dark2;
        tmp_dict_key_97 = const_str_plain_listed;
        tmp_mvar_value_98 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Dark2_data );

        if (unlikely( tmp_mvar_value_98 == NULL ))
        {
            tmp_mvar_value_98 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Dark2_data );
        }

        if ( tmp_mvar_value_98 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Dark2_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1415;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_97 = tmp_mvar_value_98;
        tmp_dict_value_96 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_96, tmp_dict_key_97, tmp_dict_value_97 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_96, tmp_dict_value_96 );
        Py_DECREF( tmp_dict_value_96 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_98 = const_str_plain_Paired;
        tmp_dict_key_99 = const_str_plain_listed;
        tmp_mvar_value_99 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Paired_data );

        if (unlikely( tmp_mvar_value_99 == NULL ))
        {
            tmp_mvar_value_99 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Paired_data );
        }

        if ( tmp_mvar_value_99 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Paired_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1416;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_99 = tmp_mvar_value_99;
        tmp_dict_value_98 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_98, tmp_dict_key_99, tmp_dict_value_99 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_98, tmp_dict_value_98 );
        Py_DECREF( tmp_dict_value_98 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_100 = const_str_plain_Pastel1;
        tmp_dict_key_101 = const_str_plain_listed;
        tmp_mvar_value_100 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Pastel1_data );

        if (unlikely( tmp_mvar_value_100 == NULL ))
        {
            tmp_mvar_value_100 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Pastel1_data );
        }

        if ( tmp_mvar_value_100 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Pastel1_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1417;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_101 = tmp_mvar_value_100;
        tmp_dict_value_100 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_100, tmp_dict_key_101, tmp_dict_value_101 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_100, tmp_dict_value_100 );
        Py_DECREF( tmp_dict_value_100 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_102 = const_str_plain_Pastel2;
        tmp_dict_key_103 = const_str_plain_listed;
        tmp_mvar_value_101 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Pastel2_data );

        if (unlikely( tmp_mvar_value_101 == NULL ))
        {
            tmp_mvar_value_101 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Pastel2_data );
        }

        if ( tmp_mvar_value_101 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Pastel2_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1418;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_103 = tmp_mvar_value_101;
        tmp_dict_value_102 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_102, tmp_dict_key_103, tmp_dict_value_103 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_102, tmp_dict_value_102 );
        Py_DECREF( tmp_dict_value_102 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_104 = const_str_plain_Set1;
        tmp_dict_key_105 = const_str_plain_listed;
        tmp_mvar_value_102 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Set1_data );

        if (unlikely( tmp_mvar_value_102 == NULL ))
        {
            tmp_mvar_value_102 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Set1_data );
        }

        if ( tmp_mvar_value_102 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Set1_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1419;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_105 = tmp_mvar_value_102;
        tmp_dict_value_104 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_104, tmp_dict_key_105, tmp_dict_value_105 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_104, tmp_dict_value_104 );
        Py_DECREF( tmp_dict_value_104 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_106 = const_str_plain_Set2;
        tmp_dict_key_107 = const_str_plain_listed;
        tmp_mvar_value_103 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Set2_data );

        if (unlikely( tmp_mvar_value_103 == NULL ))
        {
            tmp_mvar_value_103 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Set2_data );
        }

        if ( tmp_mvar_value_103 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Set2_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1420;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_107 = tmp_mvar_value_103;
        tmp_dict_value_106 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_106, tmp_dict_key_107, tmp_dict_value_107 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_106, tmp_dict_value_106 );
        Py_DECREF( tmp_dict_value_106 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_108 = const_str_plain_Set3;
        tmp_dict_key_109 = const_str_plain_listed;
        tmp_mvar_value_104 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__Set3_data );

        if (unlikely( tmp_mvar_value_104 == NULL ))
        {
            tmp_mvar_value_104 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__Set3_data );
        }

        if ( tmp_mvar_value_104 == NULL )
        {
            Py_DECREF( tmp_assign_source_135 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "_Set3_data" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1421;

            goto frame_exception_exit_1;
        }

        tmp_dict_value_109 = tmp_mvar_value_104;
        tmp_dict_value_108 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_108, tmp_dict_key_109, tmp_dict_value_109 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_108, tmp_dict_value_108 );
        Py_DECREF( tmp_dict_value_108 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_110 = const_str_plain_tab10;
        tmp_dict_key_111 = const_str_plain_listed;
        tmp_mvar_value_105 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab10_data );

        if (unlikely( tmp_mvar_value_105 == NULL ))
        {
            tmp_mvar_value_105 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__tab10_data );
        }

        CHECK_OBJECT( tmp_mvar_value_105 );
        tmp_dict_value_111 = tmp_mvar_value_105;
        tmp_dict_value_110 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_110, tmp_dict_key_111, tmp_dict_value_111 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_110, tmp_dict_value_110 );
        Py_DECREF( tmp_dict_value_110 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_112 = const_str_plain_tab20;
        tmp_dict_key_113 = const_str_plain_listed;
        tmp_mvar_value_106 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab20_data );

        if (unlikely( tmp_mvar_value_106 == NULL ))
        {
            tmp_mvar_value_106 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__tab20_data );
        }

        CHECK_OBJECT( tmp_mvar_value_106 );
        tmp_dict_value_113 = tmp_mvar_value_106;
        tmp_dict_value_112 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_112, tmp_dict_key_113, tmp_dict_value_113 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_112, tmp_dict_value_112 );
        Py_DECREF( tmp_dict_value_112 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_114 = const_str_plain_tab20b;
        tmp_dict_key_115 = const_str_plain_listed;
        tmp_mvar_value_107 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab20b_data );

        if (unlikely( tmp_mvar_value_107 == NULL ))
        {
            tmp_mvar_value_107 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__tab20b_data );
        }

        CHECK_OBJECT( tmp_mvar_value_107 );
        tmp_dict_value_115 = tmp_mvar_value_107;
        tmp_dict_value_114 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_114, tmp_dict_key_115, tmp_dict_value_115 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_114, tmp_dict_value_114 );
        Py_DECREF( tmp_dict_value_114 );
        assert( !(tmp_res != 0) );
        tmp_dict_key_116 = const_str_plain_tab20c;
        tmp_dict_key_117 = const_str_plain_listed;
        tmp_mvar_value_108 = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain__tab20c_data );

        if (unlikely( tmp_mvar_value_108 == NULL ))
        {
            tmp_mvar_value_108 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain__tab20c_data );
        }

        CHECK_OBJECT( tmp_mvar_value_108 );
        tmp_dict_value_117 = tmp_mvar_value_108;
        tmp_dict_value_116 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem( tmp_dict_value_116, tmp_dict_key_117, tmp_dict_value_117 );
        assert( !(tmp_res != 0) );
        tmp_res = PyDict_SetItem( tmp_assign_source_135, tmp_dict_key_116, tmp_dict_value_116 );
        Py_DECREF( tmp_dict_value_116 );
        assert( !(tmp_res != 0) );
        UPDATE_STRING_DICT1( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain_datad, tmp_assign_source_135 );
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ca714f50dd5177aff8ddf15c2af89b0 );
#endif
    popFrameStack();

    assertFrameObject( frame_7ca714f50dd5177aff8ddf15c2af89b0 );

    goto frame_no_exception_2;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7ca714f50dd5177aff8ddf15c2af89b0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7ca714f50dd5177aff8ddf15c2af89b0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7ca714f50dd5177aff8ddf15c2af89b0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7ca714f50dd5177aff8ddf15c2af89b0, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_2:;

#if _NUITKA_EXPERIMENTAL_PKGUTIL_ITERMODULES
#if 0 && 0
    {
        PyObject *path_value = GET_STRING_DICT_VALUE( moduledict_matplotlib$_cm, (Nuitka_StringObject *)const_str_plain___path__ );

        if (path_value && PyList_CheckExact(path_value) && PyList_Size(path_value) > 0)
        {
            PyObject *path_element = PyList_GetItem( path_value, 0 );

            PyObject *path_importer_cache = PySys_GetObject((char *)"path_importer_cache");
            CHECK_OBJECT( path_importer_cache );

            int res = PyDict_SetItem( path_importer_cache, path_element, (PyObject *)&Nuitka_Loader_Type );
            assert( res == 0 );
        }
    }
#endif
#endif

    return MOD_RETURN_VALUE( module_matplotlib$_cm );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
